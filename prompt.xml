<?xml version="1.0" encoding="UTF-8"?> <claudePrompt name="Rivo — Appointment Platform"> <summary> Build "Rivo": a premium, organic appointment management and public booking product. UI: teal + green palette, light theme, modern fonts, subtle gradients, minimal Apple-like aesthetic. Tech: React + TypeScript + Tailwind (boilerplate exists). NeonDB (Postgres) accessed via frontend drivers only. MUST ENSURE DATA CONSISTENCY. Two product surfaces: owner dashboard (manage business & appointments) and public booking pages (per-business subdomains). Output expected from you (Claude): a sequential plan and detailed non-code instructions for each step (migrations, DB init, auth, booking flows, UI guidelines, testing, deployment). </summary> <branding> <visualGoals> <item>Palette: teal and green family; primary and secondary tokens; soft neutral background.</item> <item>Light theme only; subtle, diagonal or radial micro-gradient for header/hero.</item> <item>Typography: modern UI fonts (system UI stack + Inter / SF Pro Display fallback). Large headings, ample whitespace, 48–64px hero, 16–18px body base.</item> <item>Icons: use icon library (Heroicons / Lucide / Feather). NO emojis.</item> <item>Feel: organic, premium, minimal. High-contrast accessible text. Subtle shadows, 2xl rounded cards.</item> </visualGoals> <uxConstraints> <item>No AI buzzwords anywhere in UI, text, or meta.</item> <item>All brand colors must be configurable via YAML per-tenant.</item> </uxConstraints> </branding> <productScope> <feature>Owner landing page and signup: business owners create accounts and provide business information during signup.</feature> <feature>Owner dashboard: calendar view, appointment list, modify appointments, add manual appointments, notify customers, export data.</feature> <feature>Public booking pages: one configurable subdomain per business (x-business.rivo.app) that uses a generic booking template loaded from YAML config and tenant data.</feature> <feature>Configuration: per-business YAML controls availability, services, time slot rules, branding, booking requirements, limits.</feature> <feature>Database: NeonDB (Postgres). Frontend drivers only — design must preserve security & consistency under that constraint.</feature> <feature>Auth: separate auth flows for business owners and customers. Guest bookings allowed.</feature> <feature>Notifications: email and optional SMS; transactional with retry and delivery logging.</feature> <feature>Data integrity: strict constraints, transactions, idempotency and conflict resolution patterns to prevent double-bookings. (MUST ENSURE DATA CONSISTENCY)</feature> </productScope> <tenantAndSubdomainDesign> <goal>Each tenant (business) gets a stable subdomain and isolated configuration.</goal> <requirements> <item>Wildcard DNS + TLS: support *.rivo.app pointing to the booking frontend.</item> <item>Tenant resolution: map subdomain to tenant record and to YAML config location before rendering booking UI.</item> <item>Config precedence: tenant YAML overrides platform defaults; support config versioning and validation.</item> <item>Booking page is a single, generic template that reads the tenant config and renders services, availability and booking flow.</item> </requirements> </tenantAndSubdomainDesign> <yamlConfigurationModel> <description> The YAML file is the single source of truth for per-tenant booking behavior. Validate every YAML against a schema before enabling it. </description> <requiredFields> <field>business.id — unique tenant identifier</field> <field>business.name — display name</field> <field>contact — address, email, phone</field> <field>branding — primaryColor, logoUrl, coverImageUrl</field> <field>timeSlotDuration — minutes (slot increment)</field> <field>maxSimultaneousBookings — concurrency per slot</field> <field>advanceBookingDays — how many days into future customers can book</field> <field>requireEmail, requirePhone, allowGuestBooking — booking requirements</field> <field>availability — per-day open/close times and exceptions</field> <field>categories -> services[] — service id, name, duration (minutes), price (cents), color, sortOrder</field> </requiredFields> <validation> <item>Enforce numeric bounds (e.g., timeSlotDuration > 0 and <= 480).</item> <item>Validate time formats (24h HH:MM). Validate timezone presence for tenant.</item> <item>Support an overrides mechanism for temporary changes (e.g., holiday closures).</item> </validation> </yamlConfigurationModel> <dataModelGuidelines> <goal>Define logical entities and constraints (no implementation SQL here — instruction only).</goal> <entities> <entity>business / tenant</entity> <entity>user (owners, staff, customers)</entity> <entity>service</entity> <entity>category</entity> <entity>availability / schedule / exceptions</entity> <entity>appointment</entity> <entity>reservation_token (temporary hold on a timeslot)</entity> <entity>notification_log</entity> <entity>subdomain mapping</entity> <entity>audit_log</entity> </entities> <constraintsAndIndexes> <item>Unique constraint on (business_id, service_id) where applicable.</item> <item>Unique index or constraint to prevent overlapping committed appointments beyond maxSimultaneousBookings for a timeslot.</item> <item>Index on business_id + appointment_start to speed calendar queries.</item> <item>Audit/audit_log table for changes to appointment status (created, confirmed, canceled, modified) with actor and timestamp.</item> </constraintsAndIndexes> <migrationsOverview> <item>Create migration steps that: (1) create core tables; (2) create RLS policies and roles; (3) create unique constraints and indexes; (4) seed admin account and sample tenant; (5) run schema validation tests.</item> <item>Include a migration to add a reservation/hold table with TTL semantics (expiry timestamp) to support tentative holds.</item> </migrationsOverview> <dataRetentionAndSoftDeletes> <item>Use soft deletes for appointments and business data (deleted_at). Keep audit log indefinitely.</item> </dataRetentionAndSoftDeletes> <timezones> <item>Store all timestamps in UTC in DB. Store tenant timezone and show local times on UI. Always convert and validate on client-side before writing to DB.</item> </timezones> </dataModelGuidelines> <consistencyAndConcurrency> <principles>MUST ENSURE DATA CONSISTENCY under frontend-only DB access.</principles> <mechanisms> <mechanism>Reservation flow: client creates a short-lived reservation record for a specific business/timeslot with a TTL. Reservation creation must be atomic; reservation records reserve 1 of capacity for that timeslot.</mechanism> <mechanism>Commit flow: to finalize booking, client exchanges reservation token for an appointment in a single transactional operation that verifies reservation still valid and consumes it.</mechanism> <mechanism>Unique DB constraints: enforce max simultaneous bookings at DB level (composite unique constraints or check mechanisms) so a race cannot create extra bookings.</mechanism> <mechanism>Idempotency tokens for client retries: every booking attempt uses an idempotency key stored with the reservation/appointment to allow safe retries.</mechanism> <mechanism>Optimistic locking: use a version or last_updated timestamp for edits to detect concurrent modifications and reject or reconcile conflicts.</mechanism> <mechanism>Row-Level Security (RLS): grant minimal write privileges and use JWT claims to assert tenant identity; never embed long-lived DB credentials in the client.</mechanism> <mechanism>Backstop serverless function: if frontend-only drivers cannot implement required atomic semantics safely, route critical operations through a minimal trusted function that runs transactions server-side. (Architectural note: prefer to preserve user constraint but provide a fallback option.)</mechanism> </mechanisms> <testingScenarios> <test>Simulate 100 concurrent clients attempting same timeslot to verify no overbooking.</test> <test>Simulate network retry with same idempotency key to verify single booking created.</test> <test>Verify reservation expiration and cleanup jobs remove stale reservations and free capacity.</test> </testingScenarios> </consistencyAndConcurrency> <authAndSecurity> <separationOfAuth> <item>Owner auth: scoped to tenants with roles (owner, staff). Owners must supply business info during signup.</item> <item>Customer auth: optional. Allow guest booking path that creates a lightweight customer record and issues a short-lived token tied to appointment cancellation link.</item> <item>Token management: use short-lived JWTs for direct DB access; supply scoped claims for RLS enforcement.</item> </separationOfAuth> <securityControls> <item>Never store DB credentials in plain client code. Use ephemeral token provider or Neon-managed role tokens configurable via platform.</item> <item>Enable RLS policies to prevent cross-tenant access.</item> <item>Sanitize and validate all user-supplied strings (names, emails, phone numbers).</item> <item>Use TLS everywhere. Enforce CSP and CORS rules for booking subdomains.</item> </securityControls> </authAndSecurity> <bookingFlowSpecification> <highLevelFlow> <step>Visitor opens tenant subdomain -> tenant config + availability are loaded.</step> <step>User selects category -> selects service -> UI shows available days (respecting business timezone and advanceBookingDays).</step> <step>User picks a day -> UI shows available slots computed from availability, timeSlotDuration, existing confirmed appointments, and pending reservations.</step> <step>User selects slot -> client creates reservation (short TTL) with an idempotency key -> UI prompts for contact details (email/phone) -> user submits -> client commits reservation to appointment in a transactional step -> send confirmation notification.</step> <step>If guest booking, create ephemeral customer record with a cancellation/auth token emailed to user.</step> </highLevelFlow> <edgeCases> <item>Partial overlap handling for services with durations longer than slot increment: compute occupied intervals and prevent overlaps per business rules.</item> <item>Simultaneous bookings for services that allow multiple providers or greater capacity: obey maxSimultaneousBookings.</item> <item>Timezone mismatches: validate client computed times against tenant timezone before creating reservation.</item> </edgeCases> </bookingFlowSpecification> <calendarAndDashboardGuidelines> <ownerDashboard> <capabilities> <capability>Month / week / day views and list view.</capability> <capability>Drag-and-drop reschedule with server-side validation and audit trail.</capability> <capability>Manual appointment creation (with required fields), cancellation, and bulk actions.</capability> <capability>Notifications management and quick customer contact links.</capability> </capabilities> <uxNotes> <item>Calendar must show color-coded services and capacity badges.</item> <item>Support filtering by staff member, category, and status.</item> </uxNotes> </ownerDashboard> </calendarAndDashboardGuidelines> <notificationsAndIntegrations> <channels>email (required), SMS (optional), webhooks (for third-party integrations)</channels> <reliability> <item>Record notification attempts and results in notification_log.</item> <item>Retry transient failures with exponential backoff; keep idempotency for notification sends.</item> </reliability> <integrations>calendar export (ICS), optional Google/Outlook sync, webhook for order/status changes.</integrations> </notificationsAndIntegrations> <testingAndQualityAssurance> <unitTests>Validate config parser, time slot generator, validation rules (no code here — specify tests).</unitTests> <integrationTests>Reservation + commit transactions, RLS enforcement, auth flows, reservation TTL expiration.</integrationTests> <performanceTests>Concurrent booking stress test, page load for booking template under high tenant traffic.</performanceTests> <acceptanceCriteria> <item>No overbooking in concurrency tests.</item> <item>Booking flow completes end-to-end and customers receive confirmation in 99.9% of nominal cases.</item> <item>Admin can create/modify/cancel appointments and see immediate consistent results in calendar.</item> </acceptanceCriteria> </testingAndQualityAssurance> <deploymentMonitoringBackups> <dnsAndSubdomains>Wildcard DNS + automated provisioning of TLS certificates for tenant subdomains.</dnsAndSubdomains> <observability>Application logs, DB metrics, reservation queue metrics, notification delivery metrics.</observability> <backups>Regular DB backups and point-in-time recovery; test restore procedure monthly.</backups> <failureModes> <item>If NeonDB connectivity fails, surface maintenance notice on booking pages and disable new reservations to avoid partial state.</item> </failureModes> </deploymentMonitoringBackups> <plan> <instruction>Execute the following steps in order. After completing each step, produce the deliverables specified for review. Do not skip steps.</instruction>


<step number="1">
  <title>Define canonical YAML schema & validation rules</title>
  <tasks>
    <task>Write formal field list, types, and validation rules for YAML (versioned schema).</task>
    <task>Define validation failure behavior and rollback rules for faulty configs.</task>
  </tasks>
  <deliverables>YAML schema spec, validation rules, sample valid/invalid scenarios (text only).</deliverables>
  <acceptance>Schema covers all business needs and edge cases described above.</acceptance>
</step>

<step number="2">
  <title>Design data model and migration plan</title>
  <tasks>
    <task>Produce a table-by-table description, constraints, indexes, and RLS policy descriptions.</task>
    <task>List migration steps in order, including seeding and rollback steps.</task>
  </tasks>
  <deliverables>Migration plan document and preflight checklist for running migrations safely.</deliverables>
  <acceptance>Plan enforces unique constraints and reservation semantics; migration order safe for live data.</acceptance>
</step>

<step number="3">
  <title>Auth and security design</title>
  <tasks>
    <task>Specify owner vs customer auth flows, token lifecycle, RLS claim mapping, guest booking token design.</task>
    <task>Define minimal privilege required for frontend DB operations and ephemeral token provisioning mechanism.</task>
  </tasks>
  <deliverables>Auth spec, token issuance flow, RLS claim matrix.</deliverables>
  <acceptance>Separation of roles documented and secure token lifecycle defined.</acceptance>
</step>

<step number="4">
  <title>Booking transaction & concurrency design</title>
  <tasks>
    <task>Specify reservation -> commit -> confirm lifecycle with TTL, idempotency, and failure handling.</task>
    <task>Define how DB constraints will serve as backstop and how conflicts are surfaced to the client.</task>
  </tasks>
  <deliverables>Transactional flow  and error cases with remediation steps.</deliverables>
  <acceptance>Concurrency scenarios covered; test plan defined to prove no overbooking.</acceptance>
</step>

<step number="5">
  <title>DONT DO THIS</title>
  <tasks>
    <task>Describe tenant resolution, caching strategy, YAML sourcing and validation on load, and fallback behavior.</task>
    <task>Define DNS, cert, and CDN requirements for wildcard subdomains.</task>
  </tasks>
  <deliverables>Tenant routing & config resolution doc and CDN/DNS checklist.</deliverables>
  <acceptance>Booking pages load securely with correct tenant configs applied.</acceptance>
</step>

<step number="6">
  <title>Owner dashboard UX & interactions</title>
  <tasks>
    <task>Detail calendar interactions, manual appointment creation UX, drag/drop reschedule rules, and audit behaviors.</task>
    <task>Define acceptance criteria for each interaction and API contract expectations.</task>
  </tasks>
  <deliverables>Owner dashboard and mock data scenarios for QA.</deliverables>
  <acceptance>All UX actions map to atomic server operations that preserve consistency.</acceptance>
</step>

<step number="7">
  <title>Public booking UX & slot generation</title>
  <tasks>
    <task>Describe slot generation algorithm, display rules, pagination/scrolling for long date ranges.</task>
    <task>Define guest booking experience and minimal data required, and cancellation link flow.</task>
  </tasks>
  <deliverables>Booking flow spec, UX edge cases, and telemetry hooks to track drop-off points.</deliverables>
  <acceptance>Booking flow covers all configuration permutations (e.g., required email/phone, capacity limits).</acceptance>
</step>

<step number="8">
  <title>Notifications & external integrations</title>
  <tasks>
    <task>Specify notification templates, retry logic, and webhook contract for third-party integrations.</task>
  </tasks>
  <deliverables>Notification spec and integration checklist (email provider, SMS provider, webhook schemas).</deliverables>
  <acceptance>Notifications are idempotent and logged for auditing.</acceptance>
</step>

<step number="9">
  <title>Testing, stress and QA runbook</title>
  <tasks>
    <task>Detail unit/integration/performance tests and concurrency test harness design.</task>
    <task>Define metrics to monitor before promoting to production.</task>
  </tasks>
  <deliverables>QA runbook and test case matrix.</deliverables>
  <acceptance>Pass concurrency and regression tests; acceptable error rates under load.</acceptance>
</step>

<step number="10">
  <title>Deployment, monitoring, and backup plan</title>
  <tasks>
    <task>Document CI/CD steps, migration procedure for production, rollout strategy and rollback steps.</task>
    <task>Define monitoring dashboards and alert thresholds.</task>
  </tasks>
  <deliverables>Deployment playbook and monitoring dashboard spec.</deliverables>
  <acceptance>Automated deploys, tested rollback, and monitored health checks in place.</acceptance>
</step>

<step number="11">
  <title>Post-launch: telemetry, iterative improvements</title>
  <tasks>
    <task>Collect usage data to validate UX assumptions; plan A/B experiments for conversion uplift.</task>
  </tasks>
  <deliverables>Metric definitions and first 90-day measurement plan.</deliverables>
  <acceptance>Telemetry captures booking funnel, reservation TTL expirations, and failure modes.</acceptance>
</step>
</plan> <nonFunctionalRequirements> <nfr>Accessibility: WCAG AA baseline for booking flows and owner dashboard.</nfr> <nfr>Performance: booking page first meaningful paint under 1.5s on 3G simulated (optimize assets, critical CSS).</nfr> <nfr>Security: RLS, TLS, CSP, audit logs for appointment changes.</nfr> <nfr>Scalability: design for many tenants and burst booking events; caching of tenant configs.</nfr> </nonFunctionalRequirements> <deliverableFormat> <format>For each step, return: objectives, tasks, acceptance criteria, risks and mitigations, and a short checklist of artefacts to produce next.</format> . Preserve the constraints: NO EMOJIS, NO AI BUZZWORDS, and MUST ENSURE DATA CONSISTENCY.</text> </closingInstruction> </claudePrompt>