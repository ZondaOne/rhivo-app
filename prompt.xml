<?xml version="1.0" encoding="UTF-8"?> <claudePrompt name="Rivo — Appointment Platform"> <summary> Build "Rhivo": a premium, organic appointment management and public booking product. UI: teal + green palette, light theme, modern fonts, subtle gradients, minimal Apple-like aesthetic. Tech: React + TypeScript + Tailwind (boilerplate exists). NeonDB (Postgres) accessed via frontend drivers only. MUST ENSURE DATA CONSISTENCY. Two product surfaces: owner dashboard (manage business & appointments) and public booking pages (per-business subdomains). Output expected from you (Claude): a sequential plan and detailed non-code instructions for each step (migrations, DB init, auth, booking flows, UI guidelines, testing, deployment). </summary> <branding> <visualGoals> <item>Palette: teal and green family; primary and secondary tokens; soft neutral background.</item> <item>Light theme only; subtle, diagonal or radial micro-gradient for header/hero.</item> <item>Typography: modern UI fonts (system UI stack + Inter / SF Pro Display fallback). Large headings, ample whitespace, 48–64px hero, 16–18px body base.</item> <item>Icons: use icon library (Heroicons / Lucide / Feather). NO emojis.</item> <item>Feel: organic, premium, minimal. High-contrast accessible text. Subtle shadows, 2xl rounded cards.</item> </visualGoals> <uxConstraints> <item>No AI buzzwords anywhere in UI, text, or meta.</item> <item>All brand colors must be configurable via YAML per-tenant.</item> </uxConstraints> </branding> <productScope> <feature>Owner landing page and signup: business owners create accounts and provide business information during signup.</feature> <feature>Owner dashboard: calendar view, appointment list, modify appointments, add manual appointments, notify customers, export data.</feature> <feature>Public booking pages: one configurable subdomain per business (x-business.rhivo.app) that uses a generic booking template loaded from YAML config and tenant data.</feature> <feature>Configuration: per-business YAML controls availability, services, time slot rules, branding, booking requirements, limits.</feature> <feature>Database: NeonDB (Postgres). Frontend drivers only — design must preserve security & consistency under that constraint.</feature> <feature>Auth: separate auth flows for business owners and customers. Guest bookings allowed.</feature> <feature>Notifications: email and optional SMS; transactional with retry and delivery logging.</feature> <feature>Data integrity: strict constraints, transactions, idempotency and conflict resolution patterns to prevent double-bookings. (MUST ENSURE DATA CONSISTENCY)</feature> </productScope> <tenantAndSubdomainDesign> <goal>Each tenant (business) gets a stable subdomain and isolated configuration.</goal> <requirements> <item>Wildcard DNS + TLS: support *.rhivo.app pointing to the booking frontend.</item> <item>Tenant resolution: map subdomain to tenant record and to YAML config location before rendering booking UI.</item> <item>Config precedence: tenant YAML overrides platform defaults; support config versioning and validation.</item> <item>Booking page is a single, generic template that reads the tenant config and renders services, availability and booking flow.</item> </requirements> </tenantAndSubdomainDesign> <yamlConfigurationModel> <description> The YAML file is the single source of truth for per-tenant booking behavior. Validate every YAML against a schema before enabling it. </description> <requiredFields> <field>business.id — unique tenant identifier</field> <field>business.name — display name</field> <field>contact — address, email, phone</field> <field>branding — primaryColor, logoUrl, coverImageUrl</field> <field>timeSlotDuration — minutes (slot increment)</field> <field>maxSimultaneousBookings — concurrency per slot</field> <field>advanceBookingDays — how many days into future customers can book</field> <field>requireEmail, requirePhone, allowGuestBooking — booking requirements</field> <field>availability — per-day open/close times and exceptions</field> <field>categories -> services[] — service id, name, duration (minutes), price (cents), color, sortOrder</field> </requiredFields> <validation> <item>Enforce numeric bounds (e.g., timeSlotDuration > 0 and <= 480).</item> <item>Validate time formats (24h HH:MM). Validate timezone presence for tenant.</item> <item>Support an overrides mechanism for temporary changes (e.g., holiday closures).</item> </validation> </yamlConfigurationModel> <dataModelGuidelines> <goal>Define logical entities and constraints (no implementation SQL here — instruction only).</goal> <entities> <entity>business / tenant</entity> <entity>user (owners, staff, customers)</entity> <entity>service</entity> <entity>category</entity> <entity>availability / schedule / exceptions</entity> <entity>appointment</entity> <entity>reservation_token (temporary hold on a timeslot)</entity> <entity>notification_log</entity> <entity>subdomain mapping</entity> <entity>audit_log</entity> </entities> <constraintsAndIndexes> <item>Unique constraint on (business_id, service_id) where applicable.</item> <item>Unique index or constraint to prevent overlapping committed appointments beyond maxSimultaneousBookings for a timeslot.</item> <item>Index on business_id + appointment_start to speed calendar queries.</item> <item>Audit/audit_log table for changes to appointment status (created, confirmed, canceled, modified) with actor and timestamp.</item> </constraintsAndIndexes> <migrationsOverview> <item>Create migration steps that: (1) create core tables; (2) create RLS policies and roles; (3) create unique constraints and indexes; (4) seed admin account and sample tenant; (5) run schema validation tests.</item> <item>Include a migration to add a reservation/hold table with TTL semantics (expiry timestamp) to support tentative holds.</item> </migrationsOverview> <dataRetentionAndSoftDeletes> <item>Use soft deletes for appointments and business data (deleted_at). Keep audit log indefinitely.</item> </dataRetentionAndSoftDeletes> <timezones> <item>Store all timestamps in UTC in DB. Store tenant timezone and show local times on UI. Always convert and validate on client-side before writing to DB.</item> </timezones> </dataModelGuidelines> <consistencyAndConcurrency> <principles>MUST ENSURE DATA CONSISTENCY under frontend-only DB access.</principles> <mechanisms> <mechanism>Reservation flow: client creates a short-lived reservation record for a specific business/timeslot with a TTL. Reservation creation must be atomic; reservation records reserve 1 of capacity for that timeslot.</mechanism> <mechanism>Commit flow: to finalize booking, client exchanges reservation token for an appointment in a single transactional operation that verifies reservation still valid and consumes it.</mechanism> <mechanism>Unique DB constraints: enforce max simultaneous bookings at DB level (composite unique constraints or check mechanisms) so a race cannot create extra bookings.</mechanism> <mechanism>Idempotency tokens for client retries: every booking attempt uses an idempotency key stored with the reservation/appointment to allow safe retries.</mechanism> <mechanism>Optimistic locking: use a version or last_updated timestamp for edits to detect concurrent modifications and reject or reconcile conflicts.</mechanism> <mechanism>Row-Level Security (RLS): grant minimal write privileges and use JWT claims to assert tenant identity; never embed long-lived DB credentials in the client.</mechanism> <mechanism>Backstop serverless function: if frontend-only drivers cannot implement required atomic semantics safely, route critical operations through a minimal trusted function that runs transactions server-side. (Architectural note: prefer to preserve user constraint but provide a fallback option.)</mechanism> </mechanisms> <testingScenarios> <test>Simulate 100 concurrent clients attempting same timeslot to verify no overbooking.</test> <test>Simulate network retry with same idempotency key to verify single booking created.</test> <test>Verify reservation expiration and cleanup jobs remove stale reservations and free capacity.</test> </testingScenarios> </consistencyAndConcurrency> <authAndSecurity> <separationOfAuth> <item>Owner auth: scoped to tenants with roles (owner, staff). Owners must supply business info during signup.</item> <item>Customer auth: optional. Allow guest booking path that creates a lightweight customer record and issues a short-lived token tied to appointment cancellation link.</item> <item>Token management: use short-lived JWTs for direct DB access; supply scoped claims for RLS enforcement.</item> </separationOfAuth> <securityControls> <item>Never store DB credentials in plain client code. Use ephemeral token provider or Neon-managed role tokens configurable via platform.</item> <item>Enable RLS policies to prevent cross-tenant access.</item> <item>Sanitize and validate all user-supplied strings (names, emails, phone numbers).</item> <item>Use TLS everywhere. Enforce CSP and CORS rules for booking subdomains.</item> </securityControls> </authAndSecurity> <bookingFlowSpecification> <highLevelFlow> <step>Visitor opens tenant subdomain -> tenant config + availability are loaded.</step> <step>User selects category -> selects service -> UI shows available days (respecting business timezone and advanceBookingDays).</step> <step>User picks a day -> UI shows available slots computed from availability, timeSlotDuration, existing confirmed appointments, and pending reservations.</step> <step>User selects slot -> client creates reservation (short TTL) with an idempotency key -> UI prompts for contact details (email/phone) -> user submits -> client commits reservation to appointment in a transactional step -> send confirmation notification.</step> <step>If guest booking, create ephemeral customer record with a cancellation/auth token emailed to user.</step> </highLevelFlow> <edgeCases> <item>Partial overlap handling for services with durations longer than slot increment: compute occupied intervals and prevent overlaps per business rules.</item> <item>Simultaneous bookings for services that allow multiple providers or greater capacity: obey maxSimultaneousBookings.</item> <item>Timezone mismatches: validate client computed times against tenant timezone before creating reservation.</item> </edgeCases> </bookingFlowSpecification> <calendarAndDashboardGuidelines> <ownerDashboard> <capabilities> <capability>Month / week / day views and list view.</capability> <capability>Drag-and-drop reschedule with server-side validation and audit trail.</capability> <capability>Manual appointment creation (with required fields), cancellation, and bulk actions.</capability> <capability>Notifications management and quick customer contact links.</capability> </capabilities> <uxNotes> <item>Calendar must show color-coded services and capacity badges.</item> <item>Support filtering by staff member, category, and status.</item> </uxNotes> </ownerDashboard> </calendarAndDashboardGuidelines> <notificationsAndIntegrations> <channels>email (required), SMS (optional), webhooks (for third-party integrations)</channels> <reliability> <item>Record notification attempts and results in notification_log.</item> <item>Retry transient failures with exponential backoff; keep idempotency for notification sends.</item> </reliability> <integrations>calendar export (ICS), optional Google/Outlook sync, webhook for order/status changes.</integrations> </notificationsAndIntegrations> <testingAndQualityAssurance> <unitTests>Validate config parser, time slot generator, validation rules (no code here — specify tests).</unitTests> <integrationTests>Reservation + commit transactions, RLS enforcement, auth flows, reservation TTL expiration.</integrationTests> <performanceTests>Concurrent booking stress test, page load for booking template under high tenant traffic.</performanceTests> <acceptanceCriteria> <item>No overbooking in concurrency tests.</item> <item>Booking flow completes end-to-end and customers receive confirmation in 99.9% of nominal cases.</item> <item>Admin can create/modify/cancel appointments and see immediate consistent results in calendar.</item> </acceptanceCriteria> </testingAndQualityAssurance> <deploymentMonitoringBackups> <dnsAndSubdomains>Wildcard DNS + automated provisioning of TLS certificates for tenant subdomains.</dnsAndSubdomains> <observability>Application logs, DB metrics, reservation queue metrics, notification delivery metrics.</observability> <backups>Regular DB backups and point-in-time recovery; test restore procedure monthly.</backups> <failureModes> <item>If NeonDB connectivity fails, surface maintenance notice on booking pages and disable new reservations to avoid partial state.</item> </failureModes> </deploymentMonitoringBackups> <plan> <instruction>More info can be found in /docs, document new things. Execute the following steps in order. After completing each step, produce the deliverables specified for review. Do not skip steps.</instruction>


<step number="1">
  <title>Define canonical YAML schema & validation rules</title>
  <tasks>
    <task>Write formal field list, types, and validation rules for YAML (versioned schema).</task>
    <task>Define validation failure behavior and rollback rules for faulty configs.</task>
  </tasks>
  <deliverables>YAML schema spec, validation rules, sample valid/invalid scenarios (text only).</deliverables>
  <acceptance>Schema covers all business needs and edge cases described above.</acceptance>
</step>

<step number="2">
  <title>Design data model and migration plan</title>
  <tasks>
    <task>Produce a table-by-table description, constraints, indexes, and RLS policy descriptions.</task>
    <task>List migration steps in order, including seeding and rollback steps.</task>
  </tasks>
  <deliverables>Migration plan document and preflight checklist for running migrations safely.</deliverables>
  <acceptance>Plan enforces unique constraints and reservation semantics; migration order safe for live data.</acceptance>
</step>

<step number="3">
  <title>Auth and security design</title>
  <tasks>
    <task>Specify owner vs customer auth flows, token lifecycle, RLS claim mapping, guest booking token design.</task>
    <task>Define minimal privilege required for frontend DB operations and ephemeral token provisioning mechanism.</task>
  </tasks>
  <deliverables>Auth spec, token issuance flow, RLS claim matrix.</deliverables>
  <acceptance>Separation of roles documented and secure token lifecycle defined.</acceptance>
</step>

<step number="4">
  <title>Booking transaction & concurrency design</title>
  <tasks>
    <task>Specify reservation -> commit -> confirm lifecycle with TTL, idempotency, and failure handling.</task>
    <task>Define how DB constraints will serve as backstop and how conflicts are surfaced to the client.</task>
  </tasks>
  <deliverables>Transactional flow  and error cases with remediation steps.</deliverables>
  <acceptance>Concurrency scenarios covered; test plan defined to prove no overbooking.</acceptance>
</step>

<step number="5">
  <title>DONT DO THIS</title>
  <tasks>
    <task>Describe tenant resolution, caching strategy, YAML sourcing and validation on load, and fallback behavior.</task>
    <task>Define DNS, cert, and CDN requirements for wildcard subdomains.</task>
  </tasks>
  <deliverables>Tenant routing & config resolution doc and CDN/DNS checklist.</deliverables>
  <acceptance>Booking pages load securely with correct tenant configs applied.</acceptance>
</step>

<step number="6">
  <title>Owner dashboard UX & interactions</title>
  <tasks>
    <task>Detail calendar interactions, manual appointment creation UX, drag/drop reschedule rules, and audit behaviors.</task>
    <task>Define acceptance criteria for each interaction and API contract expectations.</task>
  </tasks>
  <deliverables>Owner dashboard and mock data scenarios for QA.</deliverables>
  <acceptance>All UX actions map to atomic server operations that preserve consistency.</acceptance>
</step>

<step number="7">
  <title>Public booking UX & slot generation</title>
  <tasks>
    <task>Describe slot generation algorithm, display rules, pagination/scrolling for long date ranges.</task>
    <task>Define guest booking experience and minimal data required, and cancellation link flow.</task>
    <task>Create YAML-based tenant configuration system for per-business customization.</task>
    <task>Build customer-facing booking pages with dynamic config loading and subdomain routing.</task>
  </tasks>
  <deliverables>Booking flow spec, YAML schema, config validation system, booking page implementation, UX edge cases, and telemetry hooks to track drop-off points.</deliverables>
  <acceptance>Booking flow covers all configuration permutations (e.g., required email/phone, capacity limits). YAML configs validate correctly and populate booking pages dynamically.</acceptance>
</step>

<step number="7a">
  <title>Multi-business ownership database migration</title>
  <tasks>
    <task>Create business_owners junction table for many-to-many business-owner relationships.</task>
    <task>Migrate existing business_id data from users table to junction table without data loss.(now its mock data so we can afford to loose data if needed)</task>
    <task>Add is_primary flag to identify default/primary business for each owner.</task>
    <task>Keep users.business_id column for backward compatibility and as primary business reference.</task>
    <task>Create sync triggers to maintain consistency between users.business_id and business_owners table.</task>
    <task>Add helper functions: get_user_businesses(user_id), user_owns_business(user_id, business_id).</task>
    <task>Create indexes for fast business-owner lookups.</task>
  </tasks>
  <deliverables>Migration SQL file, junction table schema, sync triggers, helper functions, rollback plan, migration verification queries.update docs. update onboarding.</deliverables>
  <acceptance>Existing business_id relationships preserved in junction table. Owners can be associated with multiple businesses. Primary business properly tracked. No data loss during migration. Backward compatibility maintained.</acceptance>
</step>

<step number="7b">
  <title>Business onboarding pipeline - Admin/YAML flow</title>
  <tasks>
    <task>Create automated onboarding system that accepts YAML config and owner email.</task>
    <task>Generate secure temporary credentials (OTP-style password) for first-time owner access.</task>
    <task>Implement email verification flow with secure tokens.</task>
    <task>Build first-login onboarding wizard requiring immediate password change.</task>
    <task>Ensure complete data consistency: YAML config → business DB record → owner account → services → booking page.</task>
    <task>Handle edge cases: existing owner (associate new business using junction table), duplicate subdomain, invalid YAML, DB conflicts.</task>
    <task>Use business_owners junction table to support multi-business per owner with proper primary business tracking.</task>
  </tasks>
  <deliverables>Onboarding CLI tool, admin API endpoint, admin onboarding web interface, credential generation system, welcome email templates, error handling documentation.</deliverables>
  <acceptance>Complete business setup from YAML creates all DB records, owner can verify email and login, must change password on first access, bookings from customers appear in owner dashboard. Existing owners can add new businesses via junction table. Clear error messages for all failure modes.</acceptance>
</step>

<step number="7c">
  <title>Self-service onboarding - Public signup flow</title>
  <tasks>
    <task>Build form-based public signup wizard that collects all YAML properties through UI.</task>
    <task>Multi-step form: business info → contact details → branding → services/categories → availability → booking rules → review.</task>
    <task>Generate YAML configuration from form data for validation and storage.</task>
    <task>Real-time validation of each step (subdomain availability, service duration compatibility, etc).</task>
    <task>Allow owner to create account during signup (email/password) or link to existing owner account.</task>
  </tasks>
  <deliverables>Public signup form wizard, YAML generator from form data, validation system, preview functionality, subdomain availability checker.</deliverables>
  <acceptance>Non-technical business owners can self-onboard without YAML knowledge. Form validates in real-time. Generated config matches YAML schema.Process completes with functional business and booking page.</acceptance>
</step>

<step number="7d">
  <title>Password management & account recovery</title>
  <tasks>
    <task>Implement "forgot password" flow with secure reset tokens and email delivery.</task>
    <task>Build password change functionality with old password verification.</task>
    <task>Create forced password change on first login for onboarded owners.</task>
    <task>Add password strength requirements and validation.</task>
    <task>Implement rate limiting for password reset requests.</task>
  </tasks>
  <deliverables>Password reset flow, password change UI, first-login password enforcement, security policies documentation.</deliverables>
  <acceptance>Owners can reset forgotten passwords securely. First-time login requires password change. Password policies enforced.</acceptance>
</step>

<step number="7e">
  <title>Service external ID mapping for YAML-to-DB consistency</title>
  <tasks>
    <task>Add external_id column to services table to store YAML config IDs (slugs like "swedish-massage-60").</task>
    <task>Create unique constraint on (business_id, external_id) to ensure slug uniqueness per business.</task>
    <task>Update business onboarding pipeline to populate external_id from YAML service.id during service creation.</task>
    <task>Modify all booking API endpoints to accept and resolve service lookups by external_id OR UUID.</task>
    <task>Update /api/booking/reserve to handle external_id parameter and resolve to database UUID internally.</task>
    <task>Update /api/booking/slots response to include both id (UUID) and external_id for client flexibility.</task>
    <task>Create database helper function get_service_uuid(business_id, external_id) for consistent lookups.</task>
    <task>Add data migration to backfill external_id for existing services using name-based slugification as fallback.</task>
    <task>Update YAML validation to enforce external_id format rules (lowercase, alphanumeric with hyphens).</task>
    <task>Document the dual-ID system: external_id for YAML/API contracts, UUID for internal foreign keys.</task>
  </tasks>
  <deliverables>Migration SQL adding external_id column and constraints, updated onboarding code, modified booking API endpoints, service lookup helper function, backfill migration for existing data, updated API documentation showing both ID types, validation rules for external_id format.</deliverables>
  <acceptance>YAML service IDs map reliably to database records. Booking flow works with external_ids from config. No UUID exposure to public booking API. Existing services backfilled with valid external_ids. All service lookups use consistent resolution logic. API accepts both UUID (for internal/dashboard) and external_id (for public booking).</acceptance>
</step>

<step number="7f">
  <title>Flexible service duration and time slot handling (5-minute grain block system)</title>
  <tasks>
    <task>Implement 5-minute grain block system as universal time grid for all scheduling operations.</task>
    <task>Update YAML validation to auto-round durations, buffers, and timeSlotDuration to nearest 5min multiple (with console info logs).</task>
    <task>Refactor slot-generator to use 5min grain blocks: timeSlotDuration becomes DISPLAY interval, services can be any 5min multiple.</task>
    <task>Implement intelligent slot allocation that handles services spanning multiple time slots (e.g., 45min service in 30min display slots).</task>
    <task>Add overlap detection using grain block precision: check if intervals [start1, end1) and [start2, end2) conflict.</task>
    <task>Update availability API to correctly show available slots for services of varying durations (15, 45, 75, 90, 105 min).</task>
    <task>Handle edge cases: service ending mid-slot, overlapping bookings prevention, buffer time calculations at 5min granularity.</task>
    <task>Export snapToGrain() utility function for use across codebase (calendar drag-and-drop, manual entry, etc).</task>
  </tasks>
  <deliverables>5-minute grain block system implementation, updated tenant-schema.ts with auto-rounding transforms, refactored slot-generator.ts, snapToGrain() utility in calendar-utils.ts, test YAML config with edge case durations (15, 45, 75, 105 min).</deliverables>
  <acceptance>Services with any 5min-multiple duration work correctly with any timeSlotDuration. Slot availability accurately reflects occupied time using grain block overlap detection. No double-bookings occur. YAML auto-rounds non-multiples of 5 with info logs. Drag-and-drop snaps to 5min grid.</acceptance>
</step>

<step number="7f1">
  <title>Shift breaks and split shifts in YAML schema</title>
  <tasks>
    <task>Extend YAML availability schema to support multiple time slots per day for breaks and split shifts.</task>
    <task>Replace single open/close times with slots array containing {open, close} pairs in DailyAvailabilitySchema.</task>
    <task>Update tenant-schema.ts: modify DailyAvailabilitySchema to accept slots: array of TimeSlotSchema with open/close times.</task>
    <task>Maintain backward compatibility: if old format (single open/close) is detected, auto-convert to slots array with single entry.</task>
    <task>Add validation: slots must be non-overlapping and in chronological order, each slot's close > open, total daily hours reasonable.</task>
    <task>Update onboarding flow availability step to support multiple time slots per day (already implemented in UI as advanced mode).</task>
    <task>Migrate existing YAML configs to new slots format: convert single open/close to slots: [{open, close}] array.</task>
    <task>Document break/split shift examples in YAML: lunch break (9-13, 14-18), split shift (6-10, 18-22), etc.</task>
  </tasks>
  <deliverables>Updated tenant-schema.ts with slots array support, backward compatibility transformer, YAML validation for multiple slots, migration script for existing configs, break/split shift YAML examples, onboarding integration.</deliverables>
  <acceptance>YAML configs can define multiple time slots per day. Validation prevents overlapping or invalid time ranges. Existing configs with single open/close auto-convert to slots array. Onboarding UI (advanced mode) generates correct YAML with multiple slots. All break scenarios work: lunch breaks, split shifts, multiple breaks per day.</acceptance>
</step>

<step number="7f2">
  <title>Unified off-time system for slot generation</title>
  <tasks>
    <task>Design unified off-time representation: treat breaks, closed days, holidays, and unavailable exceptions as "unavailable time intervals".</task>
    <task>Create OffTimeInterval interface: {start: DateTime, end: DateTime, reason: string, type: 'closed_day' | 'break' | 'holiday' | 'exception'}.</task>
    <task>Build generateOffTimeIntervals() function that aggregates all off-time sources for a date range: closed days (availability.enabled=false), breaks (gaps between slots), holidays (availabilityExceptions.closed=true), custom exceptions.</task>
    <task>Refactor slot-generator.ts to use unified off-time system: before generating slots, compute all off-time intervals for the day, skip slot generation during off-time periods.</task>
    <task>Implement interval intersection detection: check if potential booking slot [start, end) intersects with any off-time interval using grain-block precision.</task>
    <task>Handle break transitions: ensure bookings cannot start before break and end after break (must finish before break or start after break).</task>
    <task>Add off-time validation to appointment creation/rescheduling: reject bookings that would span across breaks or closed periods.</task>
    <task>Optimize off-time checking: pre-compute daily off-time intervals and cache, use binary search or interval tree for fast overlap detection.</task>
    <task>Export isTimeAvailable() utility function: given business config, date, start/end times, returns boolean indicating if time range is available (not in off-time).</task>
    <task>Update all booking validation points to use unified off-time system: reservation creation, appointment commit, drag-and-drop reschedule, manual appointment entry.</task>
  </tasks>
  <deliverables>OffTimeInterval interface and type definitions, generateOffTimeIntervals() function, refactored slot-generator.ts using unified system, isTimeAvailable() utility, interval intersection logic, off-time caching strategy, updated booking validation across all endpoints.</deliverables>
  <acceptance>Slot generation correctly excludes all off-time: closed days, breaks between slots, holidays, exceptions. Bookings cannot span across breaks (must complete before or start after). Drag-and-drop validates against off-time intervals. Manual appointment creation rejects times during breaks or closed periods. Unified system treats all unavailable time consistently. Performance remains acceptable with complex availability patterns (multiple breaks, many exceptions). All off-time sources (slots gaps, exceptions, closures) handled by same logic.</acceptance>
</step>

<step number="7f3">
  <title>Break time visualization and booking UX</title>
  <tasks>
    <task>Add visual break indicators to calendar views: show grayed-out or hatched areas during break periods in day and week views.</task>
    <task>Display break labels in timeline: subtle "Lunch Break", "Closed", "Holiday" text overlays on off-time blocks.</task>
    <task>Implement break-aware slot selection in booking flow: when showing available time slots, clearly indicate why certain times are unavailable (break, closed, holiday).</task>
    <task>Add break information to availability API response: include off-time intervals in /api/booking/slots so frontend can display break times.</task>
    <task>Show break times on public booking page: display business hours with breaks clearly marked (e.g., "9:00 AM - 1:00 PM, 2:00 PM - 6:00 PM").</task>
    <task>Update appointment validation messages: when booking fails due to break conflict, show clear message "This time conflicts with scheduled break (1:00 PM - 2:00 PM)" do you want to continue anyway?.</task>
    <task>Handle edge case: services longer than break duration should not be offered in slots immediately before break if they would extend into break.</task>
    <task>Add business hours summary component: generate human-readable schedule from YAML config including breaks (e.g., "Mon-Fri 9-1, 2-6 | Sat 10-2").</task>
  </tasks>
  <deliverables>Break visualization in calendar UI, break labels and styling, updated booking slot API with off-time data, business hours display component, improved validation error messages, edge case handling for pre-break slots.</deliverables>
  <acceptance>Calendar views clearly show break periods as unavailable time. Booking flow displays breaks and explains why slots are unavailable. Validation errors reference specific break times. Services cannot be booked if they would extend into breaks. Public booking page shows accurate business hours including breaks. Business hours summary is human-readable and accurate.</acceptance>
</step>

<step number="7g">
  <title>Appointment drag-and-drop rescheduling with validation</title>
  <tasks>
    <task>Implement drag-and-drop rescheduling in month, week, and day calendar views with 5-minute grain snap.</task>
    <task>Create API endpoint POST /api/appointments/reschedule that validates new time slot availability before committing.</task>
    <task>Run same validation checks as booking flow: slot availability, capacity limits, business hours, advance booking limits, overlaps.</task>
    <task>Check slot capacity using existing slot-generator logic: verify new time has available capacity considering service duration + buffers.</task>
    <task>Implement optimistic locking: check appointment.updated_at hasn't changed since drag started to prevent concurrent modification conflicts.</task>
    <task>Show confirmation alert after successful reschedule: "Appointment rescheduled. Customer will be notified via email."</task>
    <task>Send notification email to customer with updated appointment time, cancellation link, and calendar attachment (.ics).</task>
    <task>Add audit log entry recording who rescheduled, old time, new time, and timestamp.</task>
    <task>Handle drag validation failures gracefully: show error toast with specific reason (fully booked, outside business hours, etc).</task>
    <task>Implement visual feedback during drag: highlight valid drop zones in green, invalid in red, show capacity indicator.</task>
  </tasks>
  <deliverables>Drag-and-drop UI implementation in Calendar.tsx (month/week/day views), POST /api/appointments/reschedule endpoint, slot availability validation logic, customer notification email template, audit logging, error handling with user-friendly messages.</deliverables>
  <acceptance>Owner can drag appointments to new time slots. System validates availability using same logic as booking flow. Invalid drops are rejected with clear error messages. Customer receives email notification on successful reschedule. Audit log captures all reschedule operations. No double-bookings or capacity violations occur.</acceptance>
</step>

<step number="7h">
  <title>Appointment edit modal for detailed modifications</title>
  <tasks>
    <task>Add edit button (pencil icon) on appointment hover in all calendar views (month, week, day, list).</task>
    <task>Create AppointmentEditModal component with form fields: date, start time (5min grain dropdown), service selector, customer info, notes, status.</task>
    <task>In list view, clicking appointment or edit button opens modal instead of inline edit.</task>
    <task>Implement time picker with 5-minute grain increments (9:00, 9:05, 9:10, etc) respecting business hours from YAML config.</task>
    <task>Add service selector dropdown that updates duration and end time preview automatically.</task>
    <task>Show real-time availability check: display capacity indicator and conflicts warning as user changes date/time.</task>
    <task>Validate form before submission: check slot availability, business hours, capacity, customer required fields.</task>
    <task>Support status changes (confirmed, cancelled, completed, no_show) with confirmation prompts for cancellations.</task>
    <task>Add "Notify customer" checkbox (default checked) to control whether customer receives update email.</task>
    <task>Implement optimistic UI updates: update calendar immediately on save, revert on error with toast notification.</task>
    <task>Add delete/cancel appointment action with confirmation dialog: "Cancel this appointment? Customer will be notified."</task>
  </tasks>
  <deliverables>AppointmentEditModal.tsx component, edit button overlay on hover, 5min-grain time picker, service selector with duration preview, real-time availability validation, status change controls, customer notification toggle, delete/cancel action, optimistic UI updates.</deliverables>
  <acceptance>Edit button appears on appointment hover in all views. Modal opens with pre-filled appointment data. Time picker shows 5-minute increments within business hours. Service changes update duration and availability in real-time. Slot validation prevents overbooking. Customer receives email when "Notify customer" is checked. Status changes and cancellations work correctly. UI updates optimistically with error rollback.</acceptance>
</step>

<step number="8">
  <title>Notifications & external integrations</title>
  <tasks>
    <task>Specify notification templates, retry logic, and webhook contract for third-party integrations.</task>
    <task>Implement welcome emails with temporary credentials for onboarded owners.</task>
    <task>Create email verification and password reset notification templates.</task>
  </tasks>
  <deliverables>Notification spec and integration checklist (email provider, SMS provider, webhook schemas). Welcome email system. Transactional email templates.</deliverables>
  <acceptance>Notifications are idempotent and logged for auditing. Onboarding emails deliver credentials securely. Email verification works reliably.</acceptance>
</step>

<step number="9">
  <title>Testing, stress and QA runbook</title>
  <tasks>
    <task>Detail unit/integration/performance tests and concurrency test harness design.</task>
    <task>Define metrics to monitor before promoting to production.</task>
  </tasks>
  <deliverables>QA runbook and test case matrix.</deliverables>
  <acceptance>Pass concurrency and regression tests; acceptable error rates under load.</acceptance>
</step>

<step number="10">
  <title>Deployment, monitoring, and backup plan</title>
  <tasks>
    <task>Document CI/CD steps, migration procedure for production, rollout strategy and rollback steps.</task>
    <task>Define monitoring dashboards and alert thresholds.</task>
  </tasks>
  <deliverables>Deployment playbook and monitoring dashboard spec.</deliverables>
  <acceptance>Automated deploys, tested rollback, and monitored health checks in place.</acceptance>
</step>

<step number="11">
  <title>Business Discovery Interface</title>
  <tasks>
    <task>Build public discovery page at /book (no subdomain) that aggregates all active businesses on the platform.</task>
    <task>Implement interactive map view showing business locations with markers and clustering for dense areas.</task>
    <task>Create list view with business cards showing name, services, next available slot, distance, and rating.</task>
    <task>Design comprehensive filter system: category (salon, spa, clinic, etc.), service type, price range, opening hours, distance radius, availability (today, this week, date range).</task>
    <task>Add search functionality with autocomplete for business name, service keywords, and location/address.</task>
    <task>Implement geolocation to show nearby businesses and calculate distances.</task>
    <task>Build business detail preview modal or card with summary, photos, top services, hours, and reviews.</task>
    <task>Create seamless redirect flow: clicking a business navigates to /book/[subdomain] for the full booking experience.</task>
    <task>Add sort options: nearest, soonest availability, highest rated, price low-to-high.</task>
    <task>Design empty states for no results and encourage filter adjustment.</task>
    <task>Optimize for performance with pagination or infinite scroll and lazy-loaded map tiles.</task>
  </tasks>
  <deliverables>Discovery page UI/UX spec, filter and search system design, map integration plan (Mapbox/Google Maps), routing logic, empty state designs, performance optimization strategy.</deliverables>
  <acceptance>Customers can browse all businesses, filter by multiple criteria, see locations on map, and seamlessly navigate to booking flow. Page loads quickly even with hundreds of businesses. Filters work in real-time and are reflected in both map and list views.</acceptance>
</step>

<step number="12">
  <title>Business Discovery Data Layer</title>
  <tasks>
    <task>Extend database schema to support discovery: add latitude/longitude, address components, business description, cover photo, featured services, operating hours summary to business table.</task>
    <task>Create indexed queries for geospatial search (ST_Distance or equivalent) and multi-criteria filtering.</task>
    <task>Build API endpoint /api/businesses/discover that accepts filter parameters and returns paginated results with metadata.</task>
    <task>Implement caching layer for discovery results (Redis or in-memory) with TTL to reduce DB load.</task>
    <task>Add business visibility toggle (active/hidden from discovery) to owner settings.</task>
    <task>Create batch job to refresh "next available slot" metadata for each business hourly.</task>
    <task>Build review/rating system (future) infrastructure if not present, or stub for later integration.</task>
    <task>Ensure RLS policies allow public read access to discovery-relevant business fields while protecting private data.</task>
  </tasks>
  <deliverables>Database migration for discovery fields, geospatial indexes, discovery API spec and implementation, caching strategy, admin toggle for visibility.</deliverables>
  <acceptance>Discovery API returns accurate, filtered business lists in &lt;500ms. Geolocation queries work correctly. Business owners can control discovery visibility. Next available slot data is fresh and accurate.</acceptance>
</step>

<step number="11a">
  <title>Geocoding Integration for Business Onboarding</title>
  <tasks>
    <task>Extend YAML schema to include geolocation fields: latitude (DECIMAL 10,8) and longitude (DECIMAL 11,8).</task>
    <task>Update tenant-schema.ts Zod validators to accept and validate latitude/longitude fields.</task>
    <task>Add address geocoding to onboarding flow: accept full address input and convert to lat/long coordinates.</task>
    <task>Implement geocoding service using free Nominatim API (OpenStreetMap) or similar geocoding service.</task>
    <task>Create address autocomplete/validation component that suggests addresses and shows coordinates preview.</task>
    <task>Store geocoded coordinates in YAML config alongside address for discovery map display.</task>
    <task>Add fallback geocoding: if coordinates not in YAML, geocode from address on-the-fly and cache result.</task>
    <task>Update existing YAML configs (wellness-spa, bella-salon) with geocoded coordinates for Italian addresses.</task>
    <task>Modify discovery API to prioritize YAML coordinates over hardcoded city lookups.</task>
  </tasks>
  <deliverables>Updated YAML schema with lat/long fields, geocoding service implementation, address input component with preview, backfilled YAML configs with coordinates, updated discovery API.</deliverables>
  <acceptance>Onboarding flow captures address and automatically geocodes to lat/long. Coordinates stored in YAML. Discovery map displays businesses at accurate locations. No hardcoded city coordinates needed.</acceptance>
</step>

<step number="11b">
  <title>Map Business Overview Cards - Hover and Zoom Interactions</title>
  <tasks>
    <task>Implement hover interaction on map markers: show compact business card overlay when mouse hovers over marker.</task>
    <task>Design minimal business overview card with: business name, primary service category, next available slot, distance from user, and thumbnail image.</task>
    <task>Add zoom-based clustering: when zoomed out, group nearby businesses into cluster markers showing count.</task>
    <task>On cluster click or hover, display aggregated overview: "X businesses in this area" with preview of top 3 businesses.</task>
    <task>Implement smooth transitions: fade in/out animations for cards, scale markers on hover, highlight active business.</task>
    <task>Create side panel (optional): when marker is clicked, slide in detailed panel from side with full business info and quick book CTA.</task>
    <task>Add keyboard navigation: allow tab through markers, space/enter to open card, escape to close.</task>
    <task>Optimize performance: debounce hover events, lazy load business images, virtual rendering for large cluster counts.</task>
    <task>Mobile UX: convert hover to tap interaction, show bottom sheet instead of overlay on mobile screens.</task>
  </tasks>
  <deliverables>Hover card component, cluster marker logic, zoom-level business aggregation, side panel UI (optional), keyboard navigation implementation, mobile-responsive interaction patterns.</deliverables>
  <acceptance>Hovering over marker shows business summary instantly. Clusters display on zoom out with business count. Click/tap opens detailed view. Smooth 60fps animations. Works seamlessly on desktop and mobile. Keyboard accessible.</acceptance>
</step>

<step number="7i">
  <title>Multiple concurrent bookings visualization in calendar views</title>
  <tasks>
    <task>Implement stacked appointment display for same time slot: show up to 3 appointments horizontally in month, week, and day views.</task>
    <task>Design visual differentiation system: use slightly different opacity/shade variations of service color for stacked appointments (100%, 85%, 70% opacity).</task>
    <task>Create overflow indicator: when more than 3 appointments exist in same slot, show first 3 and display "+N more" badge.</task>
    <task>Add hover interaction on overflow badge: show tooltip with count breakdown by service/customer.</task>
    <task>Implement click behavior on overflow badge: redirect to list view filtered to that specific time slot.</task>
    <task>Design compact appointment cards for stacked view: show essential info only (customer name/initials, service icon/initial, time if different).</task>
    <task>Handle edge cases: appointments with different durations overlapping, appointments spanning multiple time slots in stacked view.</task>
    <task>Optimize rendering: use virtualization for day/week views with many simultaneous bookings, lazy render stacked cards.</task>
    <task>Add visual capacity indicator: show subtle progress bar or color intensity based on slot capacity (e.g., 2/3 booked = 66% filled).</task>
    <task>Implement responsive behavior: in mobile/narrow views, stack vertically instead of horizontally, show max 2 before overflow.</task>
    <task>Ensure accessibility: stacked appointments must be keyboard navigable, screen reader announces "3 appointments at 10:00 AM, +2 more".</task>
  </tasks>
  <deliverables>Stacked appointment UI component, opacity/shade variation system, overflow badge with tooltip and click handler, list view time filter integration, capacity visualization, responsive stacking logic, accessibility implementation.</deliverables>
  <acceptance>Calendar views correctly display up to 3 appointments per slot with visual differentiation. Overflow badge accurately shows count and redirects to filtered list view. Capacity indicator reflects booking density. Stacking works responsively on mobile. Keyboard and screen reader accessible. Performance remains smooth with 50+ appointments in single day view.</acceptance>
</step>

<step number="7j">
  <title>Overlapping and near time slot visualization (cascade layout)</title>
  <tasks>
    <task>Implement Apple Calendar-style cascade layout for overlapping appointments: when appointments have different start times within same time window (e.g., 10:00 and 10:05), display them in cascaded columns.</task>
    <task>Design column allocation algorithm: analyze appointment overlaps and assign each to a column (max 3-4 columns before compressing width).</task>
    <task>Calculate optimal column widths: distribute available horizontal space based on number of overlapping appointments (1 column = 100% width, 2 columns = 50% each, 3 columns = 33% each, 4+ = compressed with scroll hint).</task>
    <task>Implement vertical positioning: precisely position appointment cards based on start time using minute-level granularity (5-minute grid alignment).</task>
    <task>Add visual separation: thin borders or gaps between cascaded columns to distinguish separate appointments clearly.</task>
    <task>Handle partial overlaps: appointments that overlap partially (e.g., 10:00-10:30 and 10:15-10:45) should show in adjacent columns with proper vertical alignment.</task>
    <task>Design collision detection: detect when new appointment would overlap existing ones and automatically assign to available column or create new column.</task>
    <task>Implement compress mode: when more than 4 overlapping appointments, compress column widths and show horizontal scroll indicator or "+N hidden" overlay.</task>
    <task>Add hover expansion: on hover, expand the appointment card to full width with higher z-index, showing complete details temporarily.</task>
    <task>Optimize for week/day views: cascade works best in week and day views where vertical space allows proper time-based positioning. In month view, fall back to stacking (step 7i).</task>
    <task>Handle edge cases: very short appointments (15 min), all-day appointments, appointments starting at exactly same time (use step 7i stacking).</task>
    <task>Implement smooth transitions: animate column width changes and repositioning when appointments are added/removed/rescheduled.</task>
  </tasks>
  <deliverables>Cascade layout algorithm, column allocation system, vertical positioning logic, hover expansion interaction, compression mode for dense schedules, month/week/day view-specific rendering strategies, transition animations.</deliverables>
  <acceptance>Overlapping appointments display in cascaded columns with clear visual separation. Appointments starting at different times (10:00, 10:05) show vertically offset in adjacent columns. Column widths distribute proportionally up to 4 appointments, then compress. Hover expands appointment for full details. Works smoothly in week/day views with minute-level precision. Gracefully degrades to stacking in month view. Animations are smooth at 60fps.</acceptance>
</step>

<step number="7k">
  <title>Calendar navigation and interaction refinements</title>
  <tasks>
    <task>Prevent unnecessary reschedule confirmations: detect when appointment is dragged and dropped to the exact same time slot (no change) and skip confirmation modal entirely.</task>
    <task>Implement same-position detection: compare original start time with new start time at minute-level precision using 5-minute grain alignment.</task>
    <task>Make month view calendar cells clickable: clicking an empty area of a day cell navigates to day view for that specific date.</task>
    <task>Implement appointment-specific navigation: clicking directly on an appointment card navigates to day view for that date AND scrolls/centers the view on that specific appointment.</task>
    <task>Design scroll-to-appointment animation: when navigating from month view to day view via appointment click, smoothly scroll the day view timeline to center the appointment in the viewport.</task>
    <task>Add visual highlight animation: briefly highlight the target appointment with a subtle pulse or glow effect after navigation to draw user attention.</task>
    <task>Handle edge cases: appointment at very early hour (6 AM) or very late hour (10 PM) should still center properly without scrolling beyond timeline bounds.</task>
    <task>Implement URL state management: update URL parameters when navigating to day view so browser back button works correctly (e.g., /dashboard?view=day&date=2025-01-07&appointment=abc123).</task>
    <task>Preserve context on navigation: maintain selected business, filters, and other dashboard state when switching between views.</task>
    <task>Design horizontal date picker for day view header: show selected day prominently in center with 3 days before/after, left/right chevrons for navigation.</task>
  </tasks>
  <deliverables>Drag-drop same-position detection logic, clickable calendar cell handlers, appointment-specific navigation with scroll animation, highlight pulse effect, URL state management for deep linking, browser history integration, horizontal date picker with responsive design.</deliverables>
  <acceptance>Dragging appointment to same position does not show confirmation modal. Clicking empty day cell navigates to day view for that date. Clicking appointment navigates to day view and smoothly scrolls to center that appointment with brief highlight animation. URL updates reflect current view state. Browser back/forward buttons work correctly. Day view header shows clear date picker with prominent selected day. All transitions are smooth at 60fps.</acceptance>
</step>

<step number="7l">
  <title>Calendar view transition animations and loading states</title>
  <tasks>
    <task>Implement subtle fade and slide transitions between calendar views (month, week, day, list) following functional minimalism style guide.</task>
    <task>Add smooth cross-fade animation when switching views: outgoing view fades out while incoming view fades in with slight vertical offset (8-12px) for depth perception.</task>
    <task>Create skeleton loading states for each view: show gray placeholder blocks that match final layout structure while appointments load.</task>
    <task>Design month change animation: sliding transition (left/right based on direction) with 200-300ms duration and ease-out timing.</task>
    <task>Design day change animation in day view: subtle horizontal slide (50px offset) with cross-fade for seamless date navigation via chevrons or date picker.</task>
    <task>Implement appointment data loading states: show shimmer effect on skeleton blocks using CSS gradient animation.</task>
    <task>Add smooth height transitions when calendar grid resizes (e.g., month view with 4 vs 6 weeks): animate container height changes over 250ms.</task>
    <task>Preserve scroll position where appropriate: when switching from day to week view and back, maintain scroll offset if same time range visible.</task>
    <task>Handle rapid view switching gracefully: cancel in-flight animations and transitions if user switches views quickly to prevent animation queue buildup.</task>
    <task>Implement optimistic UI updates: when changing dates or views, immediately show target state with loading overlay rather than blank screen.</task>
    <task>Add subtle loading indicator for slow connections: minimal spinner or progress bar in header that appears after 300ms delay (prevents flash for fast loads).</task>
    <task>Ensure all transitions respect prefers-reduced-motion media query: disable or reduce animations for accessibility.</task>
    <task>Test edge cases: view switching during active drag operation, rapid date navigation clicks, switching views while appointments are still loading.</task>
  </tasks>
  <deliverables>View transition animation system with fade/slide effects, skeleton loading components for all calendar views, month/day navigation animations, shimmer loading effect CSS, scroll position preservation logic, animation cancellation handlers, reduced-motion accessibility support, comprehensive loading state UI.</deliverables>
  <acceptance>All view transitions are smooth and subtle (200-300ms duration). No jarring cuts or layout shifts during navigation. Loading states accurately represent final layout structure. Skeleton loaders appear immediately, real data cross-fades in when ready. Month and day changes slide smoothly in correct direction. Rapid clicking does not cause animation conflicts or visual glitches. Scroll positions are intelligently preserved between related views. Reduced motion preference is respected. All transitions maintain 60fps performance on mid-range devices. Loading spinner only appears for genuinely slow loads (300ms+ delay).</acceptance>
</step>

<step number="7m">
  <title>Calendar data consistency and view synchronization</title>
  <tasks>
    <task>Debug and fix date/view state consistency issues: when navigating from month view to day view (e.g., day 7), then reloading page, ensure day view returns to correct date (day 7) not today's date (day 5).</task>
    <task>Fix appointment data disappearing when switching between views: ensure appointments remain visible and correctly filtered when rapidly switching month/week/day/list views.</task>
    <task>Implement proper appointment data caching strategy: cache appointments by date range to avoid unnecessary refetches when switching views with overlapping date ranges.</task>
    <task>Fix stale data display bug: prevent showing day 7 appointments in day 5 cells after navigation - ensure appointment filtering matches currently displayed date in all views.</task>
    <task>Synchronize currentDate state with URL parameters on page load: read date from URL query params and initialize calendar to that date instead of defaulting to today.</task>
    <task>Add defensive data validation: verify appointment start_time matches currently displayed date before rendering in day/week views to prevent misalignment.</task>
    <task>Implement appointment data reconciliation on view change: when switching views, verify cached data matches new view's date range requirements, refetch if necessary.</task>
    <task>Fix race condition where rapid view switching causes data to disappear: debounce or cancel in-flight API requests when user changes view before previous request completes.</task>
    <task>Add invariant checks: throw errors in development if appointments array contains dates outside currently displayed range to catch bugs early.</task>
    <task>Test data consistency across all view transition paths: month to day, day to week, week to month, list to day, with date changes and page reloads.</task>
  </tasks>
  <deliverables>Debugged and bulletproof calendar data synchronization, URL state restoration on page load, appointment caching strategy, data validation guards, race condition fixes, comprehensive test scenarios documenting expected behavior.</deliverables>
  <acceptance>Navigating between views preserves correct date and shows correct appointments. Page reload restores exact calendar state (view + date) from URL. No stale or misaligned appointment data appears in any view. Rapid view switching never causes data loss or blank screens. Cached data intelligently reuses when appropriate, refetches when necessary. All edge cases tested and documented.</acceptance>
</step>

<step number="7n">
  <title>Appointment block height alignment in layout</title>
  <tasks>
    <task>Fix appointment block vertical alignment in week and day views: when multiple appointments are horizontally split (cascade columns), ensure each block correctly spans its full duration height.</task>
    <task>Debug vertical overflow issue: when appointment is alone in its time slot (no horizontal splitting), block overflows cell vertically instead of aligning to cell boundaries.</task>
    <task>Implement consistent height calculation: appointment block height should be (duration_minutes / 60) * CELL_HEIGHT regardless of whether it shares the slot with other appointments.</task>
    <task>Fix cascade column width calculation to prevent height compression: when dividing slot width into multiple columns, preserve vertical height independently of horizontal position.</task>
    <task>Ensure appointment blocks align to 5-minute grain boundaries: top position and height must snap to grain grid to prevent half-pixel misalignments.</task>
    <task>Fix any CSS conflicts between cascade positioning (absolute with left/width) and height calculation (should use height style, not constrained by parent).</task>
  </tasks>
  <deliverables>Fixed appointment block height calculations, corrected cascade layout positioning styles, grain-aligned rendering, visual debugging helpers, test cases with varied durations and slot densities.</deliverables>
  <acceptance>Appointment blocks in week and day views correctly span their full duration vertically whether alone or in cascade columns. No vertical overflow outside hour cells. Height remains accurate when horizontally split across 2-4 columns. All appointments align precisely to 5-minute grain boundaries. Visual debugging confirms pixel-perfect alignment to grid.</acceptance>
</step>

<step number="7o">
  <title>Multi-hour appointment rendering and continuity visualization</title>
  <tasks>
    <task>Implement continuous rendering for appointments spanning multiple hours: appointments that extend beyond their starting hour (e.g., 10:00-12:30) should render as a single continuous block spanning multiple hour cells, not cropped at hour boundaries.</task>
    <task>Design vertical span calculation: detect when appointment end time exceeds starting hour boundary and calculate total vertical span across hour cells (e.g., 10:15-12:45 spans from 10:15 to end of hour 10, all of hour 11, and start to 12:45 of hour 12).</task>
    <task>Implement absolute positioning strategy: use absolute positioning with z-index to allow appointment blocks to span across multiple hour cell boundaries without being clipped by parent overflow constraints.</task>
    <task>Handle cascade layout for multi-hour appointments: when multiple multi-hour appointments overlap, ensure cascade column allocation considers the entire vertical span, not just the starting hour.</task>
    <task>Add visual continuity indicators: consider subtle visual cues (border style, background pattern) to distinguish multi-hour blocks from single-hour appointments for improved scanability.</task>
    <task>Optimize rendering performance: ensure multi-hour appointments are only rendered once in their starting hour cell (not duplicated in each spanned hour) to prevent duplicate DOM elements and event handlers.</task>
    <task>Implement hover/interaction handling: ensure multi-hour appointments respond to hover, drag, and click events across their entire vertical span, not just the visible portion in the starting hour.</task>
    <task>Handle edge cases: appointments starting before visible range and ending within range, appointments starting within range and ending after visible range, appointments spanning entire day (8+ hours).</task>
    <task>Update cascade column allocation algorithm: when calculating overlaps for multi-hour appointments, check intersections across the entire time span, not just within single hour cells.</task>
    <task>Test with various multi-hour scenarios: 1.5-hour appointments, 2-hour appointments, 3+ hour appointments, simultaneous multi-hour appointments with different durations, cascade layouts with mix of single-hour and multi-hour appointments.</task>
  </tasks>
  <deliverables>Multi-hour appointment rendering system, continuous vertical span calculation algorithm, updated cascade layout for cross-hour appointments, visual continuity design, performance-optimized rendering (single DOM element per appointment), comprehensive edge case handling, test suite with multi-hour scenarios.</deliverables>
  <acceptance>Appointments spanning multiple hours render as single continuous visual blocks without cropping at hour boundaries. A 2-hour appointment (10:00-12:00) displays as one unified block spanning two hour cells. Cascade layout correctly handles overlapping multi-hour appointments by allocating columns across the entire span. Drag-and-drop and hover interactions work seamlessly across the full appointment height. No duplicate rendering or visual artifacts. Performance remains smooth with 10+ concurrent multi-hour appointments. Edge cases (partial visibility, very long appointments) handled gracefully.</acceptance>
</step>

<step number="7p">
  <title>Customer Authentication System</title>
  <tasks>
    <task>Design and implement a customer authentication system allowing users to sign up, log in, and manage their accounts.</task>
    <task>Create a new `customers` table that can store user credentials and personal information, separate from guest bookings.</task>
    <task>Implement JWT-based authentication for customers, similar to the business owner auth system.</task>
    <task>Provide options for social logins (e.g., Google)to streamline the signup process.</task>
    <task>Create a customer dashboard where users can view their booking history, manage upcoming appointments, and update their profile.</task>
    <task>Ensure that the booking process is integrated with the customer auth system, allowing logged-in users to book appointments with pre-filled information.</task>
  </tasks>
  <deliverables>Customer auth API endpoints, database schema for `customers` table, customer dashboard UI, updated booking flow with authenticated user support.</deliverables>
  <acceptance>Customers can create accounts, log in, and view their booking history. Logged-in users have a streamlined booking experience. The system is secure and scalable.</acceptance>
</step>

<step number="7q">
  <title>Guest Booking Management with Booking ID</title>
  <tasks>
    <task>Generate a unique, human-readable "Booking ID" for each new appointment (e.g., RHIVO-ABC-123).</task>
    <task>Add a `booking_id` column to the `appointments` table and ensure it is unique.</task>
    <task>Display the Booking ID on the confirmation page and include it in all confirmation emails and SMS messages.</task>
    <task>Create a public page where a guest can enter their Booking ID and email address to access and manage their appointment (e.g., cancel or reschedule).</task>
    <task>Implement a secure token-based system to authenticate the guest for a single booking, ensuring they can only access the appointment associated with their Booking ID and email.</task>
    <task>Ensure that any changes made through the guest management page are reflected in the owner's dashboard and trigger appropriate notifications.</task>
  </tasks>
  <deliverables>Booking ID generation logic, updated `appointments` table schema, guest booking management page, secure token-based access control for guest bookings.</deliverables>
  <acceptance>Guests can manage their bookings using a unique Booking ID. The process is secure and does not require a user account. Data consistency is maintained across all booking management interfaces.</acceptance>
</step>

<step number="7r">
  <title>Customer Dashboard with Booking Management</title>
  <tasks>
    <task>Create a protected customer dashboard page that requires customer authentication (JWT-based).</task>
    <task>Build an API endpoint to fetch all appointments for the authenticated customer (both guest bookings that were linked and authenticated bookings).</task>
    <task>Display appointments in the dashboard with filters: Upcoming, Past, Canceled.</task>
    <task>Implement appointment cancellation functionality with proper validation (check cancellation policy deadline, update appointment status, release reservation slot).</task>
    <task>Implement appointment rescheduling functionality that reuses the booking flow logic: check slot availability, create new reservation, update appointment time, release old slot.</task>
    <task>Add view details functionality showing full appointment information (service, time, price, business contact, booking ID).</task>
    <task>Ensure all appointment modifications (cancel, reschedule) create audit log entries for tracking.</task>
    <task>TODO: Add notification system to alert business owner when customer cancels or reschedules (implement in step 7s).</task>
    <task>Reuse existing guest booking management endpoint logic where applicable, but ensure customer authentication takes precedence.</task>
    <task>Add proper error handling for edge cases: appointment not found, customer doesn't own appointment, appointment already canceled, past appointments cannot be modified.</task>
  </tasks>
  <deliverables>Customer dashboard UI, appointment fetch API endpoint, cancel/reschedule API endpoints, audit logging for customer actions, integration with existing booking management logic.</deliverables>
  <acceptance>Authenticated customers can view all their appointments, cancel upcoming appointments (respecting cancellation policy), and reschedule appointments (with real-time availability checking). All actions are logged and reflected in the owner dashboard. Guest booking management continues to work independently for non-authenticated users.</acceptance>
</step>

<step number="7s">
  <title>Unified Appointment Rescheduling System</title>
  <tasks>
    <task>Design a unified reschedule flow that works for both authenticated customers (via customer dashboard) and guests (via /book/manage/[booking_id]).</task>
    <task>Create API endpoint POST /api/appointments/[id]/reschedule that validates ownership (JWT for customers, guest token for guests) before allowing reschedule.</task>
    <task>Implement slot availability checking: reuse existing slot-generator logic to show available time slots for the same service, respecting business hours, capacity limits, and existing bookings.</task>
    <task>Build reservation exchange logic: create new reservation for selected time slot, atomically update appointment start/end times, release old reservation/capacity, ensure no double-booking via database constraints.</task>
    <task>Add reschedule validation rules: appointment must be in 'confirmed' status, new time must be in the future, new time must respect advance booking limits, check cancellation/reschedule policy deadlines.</task>
    <task>Implement optimistic locking for reschedule operations: check appointment.updated_at hasn't changed since fetch to prevent concurrent modification conflicts.</task>
    <task>Create audit log entries for all reschedules: capture old start/end times, new start/end times, actor (customer or guest), timestamp.</task>
    <task>Build customer dashboard reschedule UI: modal or page showing available slots for same service, calendar picker, time slot selection, confirmation step.</task>
    <task>Build guest reschedule UI at /book/manage/[booking_id]: mirror customer dashboard flow but use guest token authentication instead of JWT.</task>
    <task>Ensure data consistency: reschedule must be atomic transaction (check availability, create reservation, update appointment, release old slot, audit log) to prevent race conditions.</task>
    <task>Add notification hooks: trigger business owner notification when reschedule succeeds (implement notification sending in step 7t).</task>
    <task>Send customer confirmation: email with updated appointment details, new calendar attachment (.ics file), and cancellation link.</task>
    <task>Handle edge cases: service no longer available, business closed on new date, capacity full for new time, appointment modified by owner concurrently.</task>
  </tasks>
  <deliverables>Unified reschedule API endpoint, slot availability integration, customer dashboard reschedule UI, guest reschedule UI, atomic transaction logic, audit logging, email confirmation templates, optimistic locking implementation.</deliverables>
  <acceptance>Both authenticated customers and guests can reschedule their confirmed appointments. System validates slot availability using same logic as initial booking. No double-bookings occur due to race conditions. All reschedules are logged in audit trail. Business owners receive notifications (step 7t). Customers receive email confirmations. Concurrent modification conflicts are detected and rejected gracefully.</acceptance>
</step>

<step number="7t">
  <title>Business Owner Notification Center</title>
  <tasks>
    <task>Design a notification data model: notification type (booking created, canceled, rescheduled, etc.), recipient (business owner), status (unread/read), timestamp, related appointment ID.</task>
    <task>Create a `notifications` table with columns: id, business_id, user_id (owner), type, title, message, appointment_id, read status, created_at.</task>
    <task>Implement notification creation triggers for key events: new booking, cancellation, rescheduling, no-show marked, appointment completed.</task>
    <task>Build a notification center UI component in the business owner dashboard showing recent notifications with unread count badge.</task>
    <task>Create API endpoints: fetch notifications (with pagination), mark as read, mark all as read, delete notification.</task>
    <task>Add real-time notification badge update in the dashboard header showing unread count.</task>
    <task>Implement notification preferences: allow owners to configure which events trigger notifications (email, in-app, or both).</task>
    <task>Connect customer booking actions (cancel from step 7r, reschedule from step 7s) to notification creation so owners are immediately informed.</task>
    <task>Add notification cleanup: automatically mark notifications older than 30 days as read, archive notifications older than 90 days.</task>
  </tasks>
  <deliverables>Notifications database table, notification creation logic for booking events, notification center UI component, API endpoints for notification management, notification preferences configuration.</deliverables>
  <acceptance>Business owners see real-time notifications for all booking events. Unread notification count is visible in dashboard header. Owners can mark notifications as read and configure notification preferences. Customer actions (cancel/reschedule) immediately notify the business owner.</acceptance>
</step>

<step number="7u">
  <title>Customer Email Notifications with Resend and React Email</title>
  <tasks>
    <task>Install and configure Resend SDK and React Email libraries (resend, @react-email/components).</task>
    <task>use Resend API key in environment variables and create email service wrapper module.</task>
    <task>Design email templates using React Email components for: booking confirmation, appointment reminder (24h before), cancellation confirmation, reschedule confirmation.</task>
    <task>Build booking confirmation email template: include business name/logo, service details, appointment date/time, booking ID, customer name, cancellation/reschedule link, calendar attachment (.ics file).</task>
    <task>Build cancellation confirmation email template: confirm cancellation, show original appointment details, provide rebooking link to business booking page.</task>
    <task>Build reschedule confirmation email template: show old appointment time (strikethrough), new appointment time (highlighted), updated booking details, cancellation link.</task>
    <task>Build appointment reminder email template: sent 24 hours before appointment, include appointment details, directions/parking info if available, prepare-for-appointment instructions.</task>
    <task>Implement email delivery functions: sendBookingConfirmation(), sendCancellationConfirmation(), sendRescheduleConfirmation(), sendAppointmentReminder().</task>
    <task>Integrate email sending into booking flow: trigger sendBookingConfirmation() after successful appointment creation in /api/booking/commit.</task>
    <task>Integrate email sending into cancellation flow: trigger sendCancellationConfirmation() in customer cancel and guest cancel endpoints.</task>
    <task>Integrate email sending into reschedule flow: trigger sendRescheduleConfirmation() in unified reschedule endpoint (step 7s).</task>
    <task>Create email delivery logging table: log all email attempts with status (sent, failed, bounced), recipient, template type, appointment_id, timestamp.</task>
    <task>Implement retry logic with exponential backoff for transient email delivery failures (rate limits, temporary API errors).</task>
    <task>Add email delivery status checking: query Resend API for delivery/open/click events and update email_logs table.</task>
    <task>Design fallback strategy: if Resend fails, log error and optionally fall back to console logging in development or alternative provider in production.</task>
    <task>Ensure email templates are mobile-responsive and follow branding guidelines (teal/green color scheme, minimal design).</task>
    <task>Add unsubscribe mechanism: include unsubscribe link in reminder emails (required for transactional email compliance), store preferences in customer record.</task>
  </tasks>
  <deliverables>Resend integration module, React Email templates for all customer notifications, email delivery functions, email_logs table schema, retry logic implementation, admin preview page, mobile-responsive email designs, unsubscribe system.</deliverables>
  <acceptance>Customers receive professional, branded email confirmations immediately after booking. Cancellation and reschedule actions trigger appropriate email notifications. Emails render correctly on desktop and mobile email clients. Email delivery is logged and failures are retried automatically. Reminder emails are sent 24 hours before appointments. Admin can preview all email templates with test data. Unsubscribe link works for reminder emails.</acceptance>
</step>

<step number="7v">
  <title>Business Owner Email Notifications for Booking Events</title>
  <tasks>
    <task>Design business owner email templates using React Email: new booking notification, cancellation notification, reschedule notification, no-show marked, appointment completed.</task>
    <task>Build new booking email template: include customer name/contact, service booked, appointment date/time, booking ID, link to appointment in dashboard, total revenue for booking.</task>
    <task>Build cancellation notification email template: show canceled appointment details, customer name, original date/time, reason if provided, rebooking suggestion if applicable.</task>
    <task>Build reschedule notification email template: show customer name, old appointment time, new appointment time, booking ID, link to updated appointment in dashboard.</task>
    <task>Build no-show notification email template: appointment details, customer info, suggestion to mark as no-show in dashboard, option to contact customer.</task>
    <task>Build daily summary email template: sent each morning with summary of appointments for the day, total bookings, cancellations, revenue forecast, agenda-style list view.</task>
    <task>Implement owner email delivery functions: sendOwnerNewBookingEmail(), sendOwnerCancellationEmail(), sendOwnerRescheduleEmail(), sendDailySummaryEmail().</task>
    <task>Integrate owner email sending into booking commit flow: after in-app notification created (step 7t), trigger sendOwnerNewBookingEmail() for all business owners.</task>
    <task>Integrate owner email sending into cancellation flows: trigger sendOwnerCancellationEmail() in customer cancel, guest cancel, and owner cancel endpoints.</task>
    <task>Integrate owner email sending into reschedule flow: trigger sendOwnerRescheduleEmail() in unified reschedule endpoint and drag-and-drop reschedule (step 7g).</task>
    <task>Create owner notification preferences table: allow owners to toggle email notifications per event type (new booking, cancellation, reschedule), set daily summary preference (on/off, time of day).</task>
    <task>Build notification preferences UI in owner dashboard settings: toggles for each event type, daily summary time picker, test email button.</task>
    <task>Implement daily summary cron job: scheduled task that runs each morning, fetches today's appointments per business, generates and sends summary emails to opted-in owners.</task>
    <task>Respect notification preferences: before sending owner emails, check preferences table to ensure owner has that notification type enabled.</task>
    <task>Add multi-owner support: for businesses with multiple owners, send emails to all owners based on their individual preferences (some may opt out of certain notifications).</task>
    <task>Include actionable links in owner emails: deep links to specific appointment in dashboard, quick-action links to contact customer, mark as no-show, reschedule.</task>
    <task>Ensure owner email templates match Rhivo branding: use business logo if available, teal/green accent colors, clean minimal design.</task>
    <task>Implement email digest mode: instead of immediate emails for each event, owners can opt for hourly or daily digest combining multiple notifications into one email.</task>
  </tasks>
  <deliverables>React Email templates for owner notifications, owner email delivery functions, notification preferences table and UI, daily summary cron job, multi-owner email distribution logic, preference-respecting email triggers, deep link generation for dashboard actions.</deliverables>
  <acceptance>Business owners receive email notifications for new bookings, cancellations, and reschedules based on their preferences. Daily summary email provides agenda of today's appointments. Owners can configure notification preferences in dashboard settings. Multi-owner businesses respect individual preferences. Emails include actionable links to dashboard. Digest mode allows batching notifications. All owner emails are professional and branded.</acceptance>
</step>

<step number="7w">
  <title>Critical: YAML-Database Capacity Consistency and Per-Service Configuration</title>
  <tasks>
    <task>CRITICAL FIX: Resolve capacity configuration mismatch between YAML and database to ensure data consistency.</task>
    <task>Add maxSimultaneousBookings field to YAML service schema as optional per-service override of business-level default.</task>
    <task>Update tenant-schema.ts: extend ServiceSchema with optional maxSimultaneousBookings field (integer, min 1, max 100).</task>
    <task>Update services database table: ensure max_simultaneous_bookings column exists and can store per-service capacity values.</task>
    <task>Modify business onboarding pipeline to sync YAML capacity values to database during service creation: use service.maxSimultaneousBookings if present, otherwise fall back to business-level bookingLimits.maxSimultaneousBookings.</task>
    <task>Remove database column max_simultaneous_bookings as source of truth: all capacity checks must read from YAML config loaded in memory, never query database column directly.</task>
    <task>Refactor slot-generator.ts: pass service-specific maxSimultaneousBookings from YAML config to calculateSlotCapacity function, use this value instead of config.bookingLimits.maxSimultaneousBookings.</task>
    <task>Refactor reservation-manager.ts: modify createReservation CTE to read capacity from passed parameter instead of querying services.max_simultaneous_bookings from database.</task>
    <task>Update appointment-manager.ts: pass capacity value from YAML config when checking availability during manual appointment creation and rescheduling.</task>
    <task>Create YAML config sync validation script: on config update, verify all service capacity values are consistent between YAML and in-memory config cache.</task>
    <task>Add database migration to add buffer_before_minutes and buffer_after_minutes columns to services table for complete YAML-to-DB consistency.</task>
    <task>Update onboarding pipeline to populate buffer columns from YAML service.bufferBefore and service.bufferAfter fields during service creation.</task>
    <task>Add 5-minute grain enforcement constraints to database: ALTER TABLE services ADD CONSTRAINT check duration_minutes, buffer_before_minutes, buffer_after_minutes are multiples of 5.</task>
    <task>Update all API endpoints that query services to include buffer columns in SELECT statements and pass to slot generation logic.</task>
    <task>Document single source of truth principle: YAML config is authoritative for all booking business logic; database stores operational data only.</task>
  </tasks>
  <deliverables>Updated tenant-schema.ts with per-service capacity, refactored slot-generator.ts and reservation-manager.ts to use YAML values exclusively, database migration adding buffer columns and 5min grain constraints, updated onboarding pipeline with YAML-to-DB sync, config validation script, comprehensive documentation of data flow and source of truth architecture.</deliverables>
  <acceptance>All capacity checks use YAML configuration values exclusively. Database column max_simultaneous_bookings is deprecated or removed. Per-service capacity overrides work correctly in YAML configs. Slot generation and reservation creation produce identical availability results. Buffer times are stored in database and used consistently. 5-minute grain constraints enforced at database level prevent invalid data. Onboarding pipeline creates services with all YAML fields synced to database. No capacity mismatch between YAML config and runtime booking logic. All existing YAML configs updated with per-service capacity where needed. Load tests confirm no double-bookings under concurrent load.</acceptance>
</step>

<step number="7x">
  <title>Critical: Reservation Race Condition Fix with Database Locking</title>
  <tasks>
    <task>CRITICAL FIX: Eliminate time-of-check-to-time-of-use race condition in reservation creation that can cause double-bookings under high concurrency.</task>
    <task>Analyze current reservation-manager.ts CTE implementation: identify that WHERE clause capacity check happens outside database lock, allowing multiple transactions to pass check simultaneously.</task>
    <task>Implement PostgreSQL advisory lock strategy: add pg_advisory_xact_lock to reservation creation CTE to serialize concurrent reservation attempts for same time slot.</task>
    <task>Design lock key generation: create deterministic hash function that combines business_id, service_id, and slot_start to produce unique int8 lock key for pg_advisory_xact_lock.</task>
    <task>Update reservation-manager.ts createReservation method: add slot_lock CTE that acquires advisory lock before checking capacity and inserting reservation.</task>
    <task>Add reservation capacity trigger to database: CREATE TRIGGER reservations_capacity_check BEFORE INSERT OR UPDATE that validates capacity constraints at database level as final safety net.</task>
    <task>Implement check_reservation_capacity() function similar to check_appointment_capacity() trigger: count overlapping reservations and appointments, enforce maxSimultaneousBookings limit, raise exception if exceeded.</task>
    <task>Update unique index on reservations table: modify reservations_slot_unique_idx to NOT include expires_at in unique constraint, preventing same slot from having multiple active reservations regardless of expiry time.</task>
    <task>Handle index constraint conflicts: when multiple start times are valid for same service due to timeSlotDuration being smaller than serviceDuration, ensure uniqueness constraint accounts for this.</task>
    <task>Add transaction isolation level configuration: update withTransaction helper in db/client.ts to use SERIALIZABLE isolation for all booking-critical operations.</task>
    <task>Implement reservation cleanup monitoring: add metrics tracking for expired reservation count, cleanup job success rate, and reservation table size to detect cleanup failures early.</task>
    <task>Create load testing harness: build script that simulates 100 concurrent clients attempting to book same time slot, verify only maxSimultaneousBookings succeed and rest receive clear error messages.</task>
    <task>Add rate limiting to reservation API endpoint: prevent malicious clients from spamming reservation creation, implement per-IP limit of 10 reservations per 5 minutes.</task>
    <task>Document concurrency guarantees: update TRANSACTIONS_IMPLEMENTATION.md with detailed explanation of advisory locks, trigger safety net, and why race conditions are now prevented.</task>
  </tasks>
  <deliverables>Refactored reservation-manager.ts with advisory locks, new database trigger check_reservation_capacity(), updated unique constraints on reservations table, transaction isolation level configuration, reservation cleanup monitoring system, load testing harness proving no double-bookings, rate limiting implementation, updated concurrency documentation.</deliverables>
  <acceptance>100 concurrent reservation attempts for same slot result in exactly maxSimultaneousBookings successful reservations and remaining attempts receive "slot unavailable" error. No double-bookings occur under load testing. Advisory locks serialize concurrent access to same time slot. Database trigger provides final safety net against capacity violations. Reservation table unique constraint prevents duplicate active reservations for same slot. Transaction isolation level prevents phantom reads. Rate limiting prevents abuse. Load tests pass consistently with zero overbooking incidents. Documentation clearly explains multi-layer concurrency protection strategy.</acceptance>
</step>

<step number="7y">
  <title>Critical: Reservation Cleanup and Monitoring System</title>
  <tasks>
    <task>CRITICAL FIX: Ensure expired reservations are reliably cleaned up and do not block capacity indefinitely.</task>
    <task>Verify reservation cleanup cron job configuration: ensure vercel.json or equivalent deployment config includes cron schedule for /api/cron/cleanup-reservations running every 5 minutes.</task>
    <task>Add cleanup job health monitoring: create /api/health/reservations endpoint that returns metrics on expired reservation count, last cleanup timestamp, and average cleanup duration.</task>
    <task>Implement cleanup failure alerting: if expired reservation count exceeds 100 or last cleanup was more than 15 minutes ago, send alert to monitoring system.</task>
    <task>Add automatic cleanup fallback: if cron job fails, trigger cleanup automatically when any reservation query detects more than 50 expired reservations.</task>
    <task>Create reservation metrics dashboard: track active reservations, expired reservations, cleanup frequency, reservation-to-appointment conversion rate, and expiry TTL distribution.</task>
    <task>Optimize reservation queries: ensure all queries that check capacity use "WHERE expires_at > NOW()" filter and have proper index on expires_at column.</task>
    <task>Add reservation expiry monitoring: alert if average TTL is consistently maxed out (indicates users abandoning bookings), suggesting UX friction in booking flow.</task>
    <task>Implement graceful degradation: if reservation table size exceeds 10,000 rows, automatically trigger aggressive cleanup and log warning for investigation.</task>
    <task>Document cleanup job dependencies: ensure deployment checklist includes verifying CRON_SECRET environment variable, testing cron endpoint authentication, and monitoring setup.</task>
  </tasks>
  <deliverables>Verified cron configuration, health check endpoint, cleanup monitoring dashboard, automatic cleanup fallback mechanism, alerting system for cleanup failures, optimized reservation queries, reservation metrics tracking, graceful degradation strategy, deployment checklist updates.</deliverables>
  <acceptance>Reservation cleanup runs every 5 minutes without failure. Health endpoint returns current system state. Alerts trigger if cleanup job fails or expired reservation count is high. Automatic fallback cleanup prevents table bloat. Reservation queries are optimized with proper indexes. Metrics dashboard shows healthy reservation lifecycle. System gracefully handles cleanup failures without impacting booking availability. Documentation includes complete cleanup job setup and monitoring instructions.</acceptance>
</step>

<step number="7z">
  <title>Critical: Comprehensive Integration Testing for Data Consistency</title>
  <tasks>
    <task>CRITICAL: Build comprehensive test suite proving no double-bookings occur under all edge cases and concurrent scenarios.</task>
    <task>Create concurrency test harness: extend existing __tests__/concurrency.test.ts with additional scenarios covering YAML capacity, race conditions, and cleanup failures.</task>
    <task>Test YAML-database capacity sync: verify slot generation and reservation creation use identical capacity values from YAML config, test with various service configurations.</task>
    <task>Test per-service capacity overrides: create YAML with mixed capacity (service A: 2, service B: 1, business default: 3), verify each service respects its specific limit.</task>
    <task>Test advisory lock effectiveness: spawn 100 concurrent requests for same slot with capacity=1, verify exactly 1 succeeds and 99 fail with "slot unavailable".</task>
    <task>Test database trigger safety net: attempt to bypass application logic and insert reservation directly via SQL, verify trigger prevents capacity violation.</task>
    <task>Test reservation expiry and cleanup: create reservation, wait for expiry, verify capacity is freed, verify cleanup job removes expired record.</task>
    <task>Test idempotency key handling: make same reservation request twice with identical idempotency key, verify second request returns existing reservation instead of error.</task>
    <task>Test 5-minute grain enforcement: attempt to create service with duration=37 minutes via database insert, verify constraint prevents invalid data.</task>
    <task>Test buffer time calculations: create overlapping appointments with buffer times, verify slot generator correctly marks slots unavailable during buffer periods.</task>
    <task>Test multi-hour service booking: book 90-minute service in business with 30-minute time slots, verify slot generator shows correct availability gaps.</task>
    <task>Test capacity across service types: with business capacity=2, book service A at 10:00 and service B at 10:00, verify third booking at 10:00 is rejected if business-level capacity applies.</task>
    <task>Test optimistic locking: simulate concurrent appointment updates, verify version conflict detection prevents lost updates.</task>
    <task>Test cleanup failure scenario: disable cleanup job, create 100 expired reservations, verify system still functions and fallback cleanup triggers.</task>
    <task>Create load testing script: simulate realistic booking patterns (100 users booking across 50 time slots over 1 hour), verify no capacity violations and all bookings properly logged.</task>
    <task>Document all test scenarios and expected behaviors: create TEST_SCENARIOS.md with descriptions of each test, rationale, and acceptance criteria.</task>
  </tasks>
  <deliverables>Extended concurrency test suite with 20+ test scenarios, YAML capacity sync tests, advisory lock verification tests, trigger enforcement tests, expiry and cleanup tests, idempotency tests, grain constraint tests, buffer time tests, load testing script simulating production traffic, TEST_SCENARIOS.md documentation.</deliverables>
  <acceptance>All concurrency tests pass with zero failures. YAML and database capacity values stay synchronized. Advisory locks prevent race conditions in all scenarios. Database triggers catch any capacity violations that bypass application logic. Reservation expiry and cleanup work reliably. Idempotency prevents duplicate bookings on retry. 5-minute grain constraints enforced. Buffer times calculated correctly. Multi-hour services book without conflicts. Business-level capacity limits respected across service types. Optimistic locking detects conflicts. Cleanup failures handled gracefully. Load tests complete successfully with no overbooking incidents. Test coverage exceeds 90% for booking-critical code paths. Documentation provides clear test execution instructions and debugging guidance.</acceptance>
</step>

<step number="13">
  <title>Post-launch: telemetry, iterative improvements</title>
  <tasks>
    <task>Collect usage data to validate UX assumptions; plan A/B experiments for conversion uplift.</task>
    <task>Track discovery page metrics: search queries, filter usage, map vs list view preference, click-through rate to booking pages.</task>
  </tasks>
  <deliverables>Metric definitions and first 90-day measurement plan. Discovery funnel analytics.</deliverables>
  <acceptance>Telemetry captures booking funnel, reservation TTL expirations, failure modes, and discovery-to-booking conversion rates.</acceptance>
</step>
</plan> <nonFunctionalRequirements> <nfr>Accessibility: WCAG AA baseline for booking flows and owner dashboard.</nfr> <nfr>Performance: booking page first meaningful paint under 1.5s on 3G simulated (optimize assets, critical CSS).</nfr> <nfr>Security: RLS, TLS, CSP, audit logs for appointment changes.</nfr> <nfr>Scalability: design for many tenants and burst booking events; caching of tenant configs.</nfr> </nonFunctionalRequirements> <deliverableFormat> <format>For each step, return: objectives, tasks, acceptance criteria, risks and mitigations, and a short checklist of artefacts to produce next.</format> . Preserve the constraints: NO EMOJIS, NO AI BUZZWORDS, and MUST ENSURE DATA CONSISTENCY.</text> </closingInstruction> </claudePrompt>