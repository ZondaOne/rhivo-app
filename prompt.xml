<?xml version="1.0" encoding="UTF-8"?> <claudePrompt name="Rivo — Appointment Platform"> <summary> Build "Rivo": a premium, organic appointment management and public booking product. UI: teal + green palette, light theme, modern fonts, subtle gradients, minimal Apple-like aesthetic. Tech: React + TypeScript + Tailwind (boilerplate exists). NeonDB (Postgres) accessed via frontend drivers only. MUST ENSURE DATA CONSISTENCY. Two product surfaces: owner dashboard (manage business & appointments) and public booking pages (per-business subdomains). Output expected from you (Claude): a sequential plan and detailed non-code instructions for each step (migrations, DB init, auth, booking flows, UI guidelines, testing, deployment). </summary> <branding> <visualGoals> <item>Palette: teal and green family; primary and secondary tokens; soft neutral background.</item> <item>Light theme only; subtle, diagonal or radial micro-gradient for header/hero.</item> <item>Typography: modern UI fonts (system UI stack + Inter / SF Pro Display fallback). Large headings, ample whitespace, 48–64px hero, 16–18px body base.</item> <item>Icons: use icon library (Heroicons / Lucide / Feather). NO emojis.</item> <item>Feel: organic, premium, minimal. High-contrast accessible text. Subtle shadows, 2xl rounded cards.</item> </visualGoals> <uxConstraints> <item>No AI buzzwords anywhere in UI, text, or meta.</item> <item>All brand colors must be configurable via YAML per-tenant.</item> </uxConstraints> </branding> <productScope> <feature>Owner landing page and signup: business owners create accounts and provide business information during signup.</feature> <feature>Owner dashboard: calendar view, appointment list, modify appointments, add manual appointments, notify customers, export data.</feature> <feature>Public booking pages: one configurable subdomain per business (x-business.rivo.app) that uses a generic booking template loaded from YAML config and tenant data.</feature> <feature>Configuration: per-business YAML controls availability, services, time slot rules, branding, booking requirements, limits.</feature> <feature>Database: NeonDB (Postgres). Frontend drivers only — design must preserve security & consistency under that constraint.</feature> <feature>Auth: separate auth flows for business owners and customers. Guest bookings allowed.</feature> <feature>Notifications: email and optional SMS; transactional with retry and delivery logging.</feature> <feature>Data integrity: strict constraints, transactions, idempotency and conflict resolution patterns to prevent double-bookings. (MUST ENSURE DATA CONSISTENCY)</feature> </productScope> <tenantAndSubdomainDesign> <goal>Each tenant (business) gets a stable subdomain and isolated configuration.</goal> <requirements> <item>Wildcard DNS + TLS: support *.rivo.app pointing to the booking frontend.</item> <item>Tenant resolution: map subdomain to tenant record and to YAML config location before rendering booking UI.</item> <item>Config precedence: tenant YAML overrides platform defaults; support config versioning and validation.</item> <item>Booking page is a single, generic template that reads the tenant config and renders services, availability and booking flow.</item> </requirements> </tenantAndSubdomainDesign> <yamlConfigurationModel> <description> The YAML file is the single source of truth for per-tenant booking behavior. Validate every YAML against a schema before enabling it. </description> <requiredFields> <field>business.id — unique tenant identifier</field> <field>business.name — display name</field> <field>contact — address, email, phone</field> <field>branding — primaryColor, logoUrl, coverImageUrl</field> <field>timeSlotDuration — minutes (slot increment)</field> <field>maxSimultaneousBookings — concurrency per slot</field> <field>advanceBookingDays — how many days into future customers can book</field> <field>requireEmail, requirePhone, allowGuestBooking — booking requirements</field> <field>availability — per-day open/close times and exceptions</field> <field>categories -> services[] — service id, name, duration (minutes), price (cents), color, sortOrder</field> </requiredFields> <validation> <item>Enforce numeric bounds (e.g., timeSlotDuration > 0 and <= 480).</item> <item>Validate time formats (24h HH:MM). Validate timezone presence for tenant.</item> <item>Support an overrides mechanism for temporary changes (e.g., holiday closures).</item> </validation> </yamlConfigurationModel> <dataModelGuidelines> <goal>Define logical entities and constraints (no implementation SQL here — instruction only).</goal> <entities> <entity>business / tenant</entity> <entity>user (owners, staff, customers)</entity> <entity>service</entity> <entity>category</entity> <entity>availability / schedule / exceptions</entity> <entity>appointment</entity> <entity>reservation_token (temporary hold on a timeslot)</entity> <entity>notification_log</entity> <entity>subdomain mapping</entity> <entity>audit_log</entity> </entities> <constraintsAndIndexes> <item>Unique constraint on (business_id, service_id) where applicable.</item> <item>Unique index or constraint to prevent overlapping committed appointments beyond maxSimultaneousBookings for a timeslot.</item> <item>Index on business_id + appointment_start to speed calendar queries.</item> <item>Audit/audit_log table for changes to appointment status (created, confirmed, canceled, modified) with actor and timestamp.</item> </constraintsAndIndexes> <migrationsOverview> <item>Create migration steps that: (1) create core tables; (2) create RLS policies and roles; (3) create unique constraints and indexes; (4) seed admin account and sample tenant; (5) run schema validation tests.</item> <item>Include a migration to add a reservation/hold table with TTL semantics (expiry timestamp) to support tentative holds.</item> </migrationsOverview> <dataRetentionAndSoftDeletes> <item>Use soft deletes for appointments and business data (deleted_at). Keep audit log indefinitely.</item> </dataRetentionAndSoftDeletes> <timezones> <item>Store all timestamps in UTC in DB. Store tenant timezone and show local times on UI. Always convert and validate on client-side before writing to DB.</item> </timezones> </dataModelGuidelines> <consistencyAndConcurrency> <principles>MUST ENSURE DATA CONSISTENCY under frontend-only DB access.</principles> <mechanisms> <mechanism>Reservation flow: client creates a short-lived reservation record for a specific business/timeslot with a TTL. Reservation creation must be atomic; reservation records reserve 1 of capacity for that timeslot.</mechanism> <mechanism>Commit flow: to finalize booking, client exchanges reservation token for an appointment in a single transactional operation that verifies reservation still valid and consumes it.</mechanism> <mechanism>Unique DB constraints: enforce max simultaneous bookings at DB level (composite unique constraints or check mechanisms) so a race cannot create extra bookings.</mechanism> <mechanism>Idempotency tokens for client retries: every booking attempt uses an idempotency key stored with the reservation/appointment to allow safe retries.</mechanism> <mechanism>Optimistic locking: use a version or last_updated timestamp for edits to detect concurrent modifications and reject or reconcile conflicts.</mechanism> <mechanism>Row-Level Security (RLS): grant minimal write privileges and use JWT claims to assert tenant identity; never embed long-lived DB credentials in the client.</mechanism> <mechanism>Backstop serverless function: if frontend-only drivers cannot implement required atomic semantics safely, route critical operations through a minimal trusted function that runs transactions server-side. (Architectural note: prefer to preserve user constraint but provide a fallback option.)</mechanism> </mechanisms> <testingScenarios> <test>Simulate 100 concurrent clients attempting same timeslot to verify no overbooking.</test> <test>Simulate network retry with same idempotency key to verify single booking created.</test> <test>Verify reservation expiration and cleanup jobs remove stale reservations and free capacity.</test> </testingScenarios> </consistencyAndConcurrency> <authAndSecurity> <separationOfAuth> <item>Owner auth: scoped to tenants with roles (owner, staff). Owners must supply business info during signup.</item> <item>Customer auth: optional. Allow guest booking path that creates a lightweight customer record and issues a short-lived token tied to appointment cancellation link.</item> <item>Token management: use short-lived JWTs for direct DB access; supply scoped claims for RLS enforcement.</item> </separationOfAuth> <securityControls> <item>Never store DB credentials in plain client code. Use ephemeral token provider or Neon-managed role tokens configurable via platform.</item> <item>Enable RLS policies to prevent cross-tenant access.</item> <item>Sanitize and validate all user-supplied strings (names, emails, phone numbers).</item> <item>Use TLS everywhere. Enforce CSP and CORS rules for booking subdomains.</item> </securityControls> </authAndSecurity> <bookingFlowSpecification> <highLevelFlow> <step>Visitor opens tenant subdomain -> tenant config + availability are loaded.</step> <step>User selects category -> selects service -> UI shows available days (respecting business timezone and advanceBookingDays).</step> <step>User picks a day -> UI shows available slots computed from availability, timeSlotDuration, existing confirmed appointments, and pending reservations.</step> <step>User selects slot -> client creates reservation (short TTL) with an idempotency key -> UI prompts for contact details (email/phone) -> user submits -> client commits reservation to appointment in a transactional step -> send confirmation notification.</step> <step>If guest booking, create ephemeral customer record with a cancellation/auth token emailed to user.</step> </highLevelFlow> <edgeCases> <item>Partial overlap handling for services with durations longer than slot increment: compute occupied intervals and prevent overlaps per business rules.</item> <item>Simultaneous bookings for services that allow multiple providers or greater capacity: obey maxSimultaneousBookings.</item> <item>Timezone mismatches: validate client computed times against tenant timezone before creating reservation.</item> </edgeCases> </bookingFlowSpecification> <calendarAndDashboardGuidelines> <ownerDashboard> <capabilities> <capability>Month / week / day views and list view.</capability> <capability>Drag-and-drop reschedule with server-side validation and audit trail.</capability> <capability>Manual appointment creation (with required fields), cancellation, and bulk actions.</capability> <capability>Notifications management and quick customer contact links.</capability> </capabilities> <uxNotes> <item>Calendar must show color-coded services and capacity badges.</item> <item>Support filtering by staff member, category, and status.</item> </uxNotes> </ownerDashboard> </calendarAndDashboardGuidelines> <notificationsAndIntegrations> <channels>email (required), SMS (optional), webhooks (for third-party integrations)</channels> <reliability> <item>Record notification attempts and results in notification_log.</item> <item>Retry transient failures with exponential backoff; keep idempotency for notification sends.</item> </reliability> <integrations>calendar export (ICS), optional Google/Outlook sync, webhook for order/status changes.</integrations> </notificationsAndIntegrations> <testingAndQualityAssurance> <unitTests>Validate config parser, time slot generator, validation rules (no code here — specify tests).</unitTests> <integrationTests>Reservation + commit transactions, RLS enforcement, auth flows, reservation TTL expiration.</integrationTests> <performanceTests>Concurrent booking stress test, page load for booking template under high tenant traffic.</performanceTests> <acceptanceCriteria> <item>No overbooking in concurrency tests.</item> <item>Booking flow completes end-to-end and customers receive confirmation in 99.9% of nominal cases.</item> <item>Admin can create/modify/cancel appointments and see immediate consistent results in calendar.</item> </acceptanceCriteria> </testingAndQualityAssurance> <deploymentMonitoringBackups> <dnsAndSubdomains>Wildcard DNS + automated provisioning of TLS certificates for tenant subdomains.</dnsAndSubdomains> <observability>Application logs, DB metrics, reservation queue metrics, notification delivery metrics.</observability> <backups>Regular DB backups and point-in-time recovery; test restore procedure monthly.</backups> <failureModes> <item>If NeonDB connectivity fails, surface maintenance notice on booking pages and disable new reservations to avoid partial state.</item> </failureModes> </deploymentMonitoringBackups> <plan> <instruction>More info can be found in /docs, document new things. Execute the following steps in order. After completing each step, produce the deliverables specified for review. Do not skip steps.</instruction>


<step number="1">
  <title>Define canonical YAML schema & validation rules</title>
  <tasks>
    <task>Write formal field list, types, and validation rules for YAML (versioned schema).</task>
    <task>Define validation failure behavior and rollback rules for faulty configs.</task>
  </tasks>
  <deliverables>YAML schema spec, validation rules, sample valid/invalid scenarios (text only).</deliverables>
  <acceptance>Schema covers all business needs and edge cases described above.</acceptance>
</step>

<step number="2">
  <title>Design data model and migration plan</title>
  <tasks>
    <task>Produce a table-by-table description, constraints, indexes, and RLS policy descriptions.</task>
    <task>List migration steps in order, including seeding and rollback steps.</task>
  </tasks>
  <deliverables>Migration plan document and preflight checklist for running migrations safely.</deliverables>
  <acceptance>Plan enforces unique constraints and reservation semantics; migration order safe for live data.</acceptance>
</step>

<step number="3">
  <title>Auth and security design</title>
  <tasks>
    <task>Specify owner vs customer auth flows, token lifecycle, RLS claim mapping, guest booking token design.</task>
    <task>Define minimal privilege required for frontend DB operations and ephemeral token provisioning mechanism.</task>
  </tasks>
  <deliverables>Auth spec, token issuance flow, RLS claim matrix.</deliverables>
  <acceptance>Separation of roles documented and secure token lifecycle defined.</acceptance>
</step>

<step number="4">
  <title>Booking transaction & concurrency design</title>
  <tasks>
    <task>Specify reservation -> commit -> confirm lifecycle with TTL, idempotency, and failure handling.</task>
    <task>Define how DB constraints will serve as backstop and how conflicts are surfaced to the client.</task>
  </tasks>
  <deliverables>Transactional flow  and error cases with remediation steps.</deliverables>
  <acceptance>Concurrency scenarios covered; test plan defined to prove no overbooking.</acceptance>
</step>

<step number="5">
  <title>DONT DO THIS</title>
  <tasks>
    <task>Describe tenant resolution, caching strategy, YAML sourcing and validation on load, and fallback behavior.</task>
    <task>Define DNS, cert, and CDN requirements for wildcard subdomains.</task>
  </tasks>
  <deliverables>Tenant routing & config resolution doc and CDN/DNS checklist.</deliverables>
  <acceptance>Booking pages load securely with correct tenant configs applied.</acceptance>
</step>

<step number="6">
  <title>Owner dashboard UX & interactions</title>
  <tasks>
    <task>Detail calendar interactions, manual appointment creation UX, drag/drop reschedule rules, and audit behaviors.</task>
    <task>Define acceptance criteria for each interaction and API contract expectations.</task>
  </tasks>
  <deliverables>Owner dashboard and mock data scenarios for QA.</deliverables>
  <acceptance>All UX actions map to atomic server operations that preserve consistency.</acceptance>
</step>

<step number="7">
  <title>Public booking UX & slot generation</title>
  <tasks>
    <task>Describe slot generation algorithm, display rules, pagination/scrolling for long date ranges.</task>
    <task>Define guest booking experience and minimal data required, and cancellation link flow.</task>
    <task>Create YAML-based tenant configuration system for per-business customization.</task>
    <task>Build customer-facing booking pages with dynamic config loading and subdomain routing.</task>
  </tasks>
  <deliverables>Booking flow spec, YAML schema, config validation system, booking page implementation, UX edge cases, and telemetry hooks to track drop-off points.</deliverables>
  <acceptance>Booking flow covers all configuration permutations (e.g., required email/phone, capacity limits). YAML configs validate correctly and populate booking pages dynamically.</acceptance>
</step>

<step number="7a">
  <title>Multi-business ownership database migration</title>
  <tasks>
    <task>Create business_owners junction table for many-to-many business-owner relationships.</task>
    <task>Migrate existing business_id data from users table to junction table without data loss.(now its mock data so we can afford to loose data if needed)</task>
    <task>Add is_primary flag to identify default/primary business for each owner.</task>
    <task>Keep users.business_id column for backward compatibility and as primary business reference.</task>
    <task>Create sync triggers to maintain consistency between users.business_id and business_owners table.</task>
    <task>Add helper functions: get_user_businesses(user_id), user_owns_business(user_id, business_id).</task>
    <task>Create indexes for fast business-owner lookups.</task>
  </tasks>
  <deliverables>Migration SQL file, junction table schema, sync triggers, helper functions, rollback plan, migration verification queries.update docs. update onboarding.</deliverables>
  <acceptance>Existing business_id relationships preserved in junction table. Owners can be associated with multiple businesses. Primary business properly tracked. No data loss during migration. Backward compatibility maintained.</acceptance>
</step>

<step number="7b">
  <title>Business onboarding pipeline - Admin/YAML flow</title>
  <tasks>
    <task>Create automated onboarding system that accepts YAML config and owner email.</task>
    <task>Generate secure temporary credentials (OTP-style password) for first-time owner access.</task>
    <task>Implement email verification flow with secure tokens.</task>
    <task>Build first-login onboarding wizard requiring immediate password change.</task>
    <task>Ensure complete data consistency: YAML config → business DB record → owner account → services → booking page.</task>
    <task>Handle edge cases: existing owner (associate new business using junction table), duplicate subdomain, invalid YAML, DB conflicts.</task>
    <task>Use business_owners junction table to support multi-business per owner with proper primary business tracking.</task>
  </tasks>
  <deliverables>Onboarding CLI tool, admin API endpoint, admin onboarding web interface, credential generation system, welcome email templates, error handling documentation.</deliverables>
  <acceptance>Complete business setup from YAML creates all DB records, owner can verify email and login, must change password on first access, bookings from customers appear in owner dashboard. Existing owners can add new businesses via junction table. Clear error messages for all failure modes.</acceptance>
</step>

<step number="7c">
  <title>Self-service onboarding - Public signup flow</title>
  <tasks>
    <task>Build form-based public signup wizard that collects all YAML properties through UI.</task>
    <task>Multi-step form: business info → contact details → branding → services/categories → availability → booking rules → review.</task>
    <task>Generate YAML configuration from form data for validation and storage.</task>
    <task>Real-time validation of each step (subdomain availability, service duration compatibility, etc).</task>
    <task>Allow owner to create account during signup (email/password) or link to existing owner account.</task>
    <task>Preview booking page before finalizing to ensure branding/services look correct.</task>
    <task>Automatic subdomain suggestion based on business name with availability check.</task>
  </tasks>
  <deliverables>Public signup form wizard, YAML generator from form data, validation system, preview functionality, subdomain availability checker.</deliverables>
  <acceptance>Non-technical business owners can self-onboard without YAML knowledge. Form validates in real-time. Generated config matches YAML schema. Preview accurately shows final booking page. Process completes with functional business and booking page.</acceptance>
</step>

<step number="7d">
  <title>Password management & account recovery</title>
  <tasks>
    <task>Implement "forgot password" flow with secure reset tokens and email delivery.</task>
    <task>Build password change functionality with old password verification.</task>
    <task>Create forced password change on first login for onboarded owners.</task>
    <task>Add password strength requirements and validation.</task>
    <task>Implement rate limiting for password reset requests.</task>
  </tasks>
  <deliverables>Password reset flow, password change UI, first-login password enforcement, security policies documentation.</deliverables>
  <acceptance>Owners can reset forgotten passwords securely. First-time login requires password change. Password policies enforced. Rate limiting prevents abuse.</acceptance>
</step>

<step number="7e">
  <title>Service external ID mapping for YAML-to-DB consistency</title>
  <tasks>
    <task>Add external_id column to services table to store YAML config IDs (slugs like "swedish-massage-60").</task>
    <task>Create unique constraint on (business_id, external_id) to ensure slug uniqueness per business.</task>
    <task>Update business onboarding pipeline to populate external_id from YAML service.id during service creation.</task>
    <task>Modify all booking API endpoints to accept and resolve service lookups by external_id OR UUID.</task>
    <task>Update /api/booking/reserve to handle external_id parameter and resolve to database UUID internally.</task>
    <task>Update /api/booking/slots response to include both id (UUID) and external_id for client flexibility.</task>
    <task>Create database helper function get_service_uuid(business_id, external_id) for consistent lookups.</task>
    <task>Add data migration to backfill external_id for existing services using name-based slugification as fallback.</task>
    <task>Update YAML validation to enforce external_id format rules (lowercase, alphanumeric with hyphens).</task>
    <task>Document the dual-ID system: external_id for YAML/API contracts, UUID for internal foreign keys.</task>
  </tasks>
  <deliverables>Migration SQL adding external_id column and constraints, updated onboarding code, modified booking API endpoints, service lookup helper function, backfill migration for existing data, updated API documentation showing both ID types, validation rules for external_id format.</deliverables>
  <acceptance>YAML service IDs map reliably to database records. Booking flow works with external_ids from config. No UUID exposure to public booking API. Existing services backfilled with valid external_ids. All service lookups use consistent resolution logic. API accepts both UUID (for internal/dashboard) and external_id (for public booking).</acceptance>
</step>

<step number="7f">
  <title>Flexible service duration and time slot handling</title>
  <tasks>
    <task>Update YAML validation to allow service durations that don't perfectly align with timeSlotDuration.</task>
    <task>Implement intelligent slot allocation that handles services spanning multiple time slots (e.g., 45min service in 30min slots).</task>
    <task>Add slot calculation logic to reserve consecutive slots for services longer than base slot duration.</task>
    <task>Update availability API to correctly show available slots for services of varying durations.</task>
    <task>Handle edge cases: service ending mid-slot, overlapping bookings prevention, buffer time calculations.</task>
    <task>Add validation warnings (not errors) when service duration is not a clean multiple of slot duration.</task>
    <task>Update booking UI to clearly show time commitment for non-standard duration services.</task>
  </tasks>
  <deliverables>Enhanced slot calculation algorithm, updated YAML schema validation, booking flow that handles arbitrary service durations, test cases for edge scenarios (15min, 45min, 75min services with 30min slots).</deliverables>
  <acceptance>Services with any duration (15, 45, 75, 90, 105 minutes) work correctly with any timeSlotDuration. Slot availability accurately reflects occupied time. No double-bookings occur. YAML validation provides helpful warnings but doesn't block non-multiples.</acceptance>
</step>

<step number="8">
  <title>Notifications & external integrations</title>
  <tasks>
    <task>Specify notification templates, retry logic, and webhook contract for third-party integrations.</task>
    <task>Implement welcome emails with temporary credentials for onboarded owners.</task>
    <task>Create email verification and password reset notification templates.</task>
  </tasks>
  <deliverables>Notification spec and integration checklist (email provider, SMS provider, webhook schemas). Welcome email system. Transactional email templates.</deliverables>
  <acceptance>Notifications are idempotent and logged for auditing. Onboarding emails deliver credentials securely. Email verification works reliably.</acceptance>
</step>

<step number="9">
  <title>Testing, stress and QA runbook</title>
  <tasks>
    <task>Detail unit/integration/performance tests and concurrency test harness design.</task>
    <task>Define metrics to monitor before promoting to production.</task>
  </tasks>
  <deliverables>QA runbook and test case matrix.</deliverables>
  <acceptance>Pass concurrency and regression tests; acceptable error rates under load.</acceptance>
</step>

<step number="10">
  <title>Deployment, monitoring, and backup plan</title>
  <tasks>
    <task>Document CI/CD steps, migration procedure for production, rollout strategy and rollback steps.</task>
    <task>Define monitoring dashboards and alert thresholds.</task>
  </tasks>
  <deliverables>Deployment playbook and monitoring dashboard spec.</deliverables>
  <acceptance>Automated deploys, tested rollback, and monitored health checks in place.</acceptance>
</step>

<step number="11">
  <title>Business Discovery Interface</title>
  <tasks>
    <task>Build public discovery page at /book (no subdomain) that aggregates all active businesses on the platform.</task>
    <task>Implement interactive map view showing business locations with markers and clustering for dense areas.</task>
    <task>Create list view with business cards showing name, services, next available slot, distance, and rating.</task>
    <task>Design comprehensive filter system: category (salon, spa, clinic, etc.), service type, price range, opening hours, distance radius, availability (today, this week, date range).</task>
    <task>Add search functionality with autocomplete for business name, service keywords, and location/address.</task>
    <task>Implement geolocation to show nearby businesses and calculate distances.</task>
    <task>Build business detail preview modal or card with summary, photos, top services, hours, and reviews.</task>
    <task>Create seamless redirect flow: clicking a business navigates to /book/[subdomain] for the full booking experience.</task>
    <task>Add sort options: nearest, soonest availability, highest rated, price low-to-high.</task>
    <task>Design empty states for no results and encourage filter adjustment.</task>
    <task>Optimize for performance with pagination or infinite scroll and lazy-loaded map tiles.</task>
  </tasks>
  <deliverables>Discovery page UI/UX spec, filter and search system design, map integration plan (Mapbox/Google Maps), routing logic, empty state designs, performance optimization strategy.</deliverables>
  <acceptance>Customers can browse all businesses, filter by multiple criteria, see locations on map, and seamlessly navigate to booking flow. Page loads quickly even with hundreds of businesses. Filters work in real-time and are reflected in both map and list views.</acceptance>
</step>

<step number="12">
  <title>Business Discovery Data Layer</title>
  <tasks>
    <task>Extend database schema to support discovery: add latitude/longitude, address components, business description, cover photo, featured services, operating hours summary to business table.</task>
    <task>Create indexed queries for geospatial search (ST_Distance or equivalent) and multi-criteria filtering.</task>
    <task>Build API endpoint /api/businesses/discover that accepts filter parameters and returns paginated results with metadata.</task>
    <task>Implement caching layer for discovery results (Redis or in-memory) with TTL to reduce DB load.</task>
    <task>Add business visibility toggle (active/hidden from discovery) to owner settings.</task>
    <task>Create batch job to refresh "next available slot" metadata for each business hourly.</task>
    <task>Build review/rating system (future) infrastructure if not present, or stub for later integration.</task>
    <task>Ensure RLS policies allow public read access to discovery-relevant business fields while protecting private data.</task>
  </tasks>
  <deliverables>Database migration for discovery fields, geospatial indexes, discovery API spec and implementation, caching strategy, admin toggle for visibility.</deliverables>
  <acceptance>Discovery API returns accurate, filtered business lists in &lt;500ms. Geolocation queries work correctly. Business owners can control discovery visibility. Next available slot data is fresh and accurate.</acceptance>
</step>

<step number="13">
  <title>Post-launch: telemetry, iterative improvements</title>
  <tasks>
    <task>Collect usage data to validate UX assumptions; plan A/B experiments for conversion uplift.</task>
    <task>Track discovery page metrics: search queries, filter usage, map vs list view preference, click-through rate to booking pages.</task>
  </tasks>
  <deliverables>Metric definitions and first 90-day measurement plan. Discovery funnel analytics.</deliverables>
  <acceptance>Telemetry captures booking funnel, reservation TTL expirations, failure modes, and discovery-to-booking conversion rates.</acceptance>
</step>
</plan> <nonFunctionalRequirements> <nfr>Accessibility: WCAG AA baseline for booking flows and owner dashboard.</nfr> <nfr>Performance: booking page first meaningful paint under 1.5s on 3G simulated (optimize assets, critical CSS).</nfr> <nfr>Security: RLS, TLS, CSP, audit logs for appointment changes.</nfr> <nfr>Scalability: design for many tenants and burst booking events; caching of tenant configs.</nfr> </nonFunctionalRequirements> <deliverableFormat> <format>For each step, return: objectives, tasks, acceptance criteria, risks and mitigations, and a short checklist of artefacts to produce next.</format> . Preserve the constraints: NO EMOJIS, NO AI BUZZWORDS, and MUST ENSURE DATA CONSISTENCY.</text> </closingInstruction> </claudePrompt>