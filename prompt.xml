<?xml version="1.0" encoding="UTF-8"?> <claudePrompt name="Rivo — Appointment Platform"> <summary> Build "Rivo": a premium, organic appointment management and public booking product. UI: teal + green palette, light theme, modern fonts, subtle gradients, minimal Apple-like aesthetic. Tech: React + TypeScript + Tailwind (boilerplate exists). NeonDB (Postgres) accessed via frontend drivers only. MUST ENSURE DATA CONSISTENCY. Two product surfaces: owner dashboard (manage business & appointments) and public booking pages (per-business subdomains). Output expected from you (Claude): a sequential plan and detailed non-code instructions for each step (migrations, DB init, auth, booking flows, UI guidelines, testing, deployment). </summary> <branding> <visualGoals> <item>Palette: teal and green family; primary and secondary tokens; soft neutral background.</item> <item>Light theme only; subtle, diagonal or radial micro-gradient for header/hero.</item> <item>Typography: modern UI fonts (system UI stack + Inter / SF Pro Display fallback). Large headings, ample whitespace, 48–64px hero, 16–18px body base.</item> <item>Icons: use icon library (Heroicons / Lucide / Feather). NO emojis.</item> <item>Feel: organic, premium, minimal. High-contrast accessible text. Subtle shadows, 2xl rounded cards.</item> </visualGoals> <uxConstraints> <item>No AI buzzwords anywhere in UI, text, or meta.</item> <item>All brand colors must be configurable via YAML per-tenant.</item> </uxConstraints> </branding> <productScope> <feature>Owner landing page and signup: business owners create accounts and provide business information during signup.</feature> <feature>Owner dashboard: calendar view, appointment list, modify appointments, add manual appointments, notify customers, export data.</feature> <feature>Public booking pages: one configurable subdomain per business (x-business.rivo.app) that uses a generic booking template loaded from YAML config and tenant data.</feature> <feature>Configuration: per-business YAML controls availability, services, time slot rules, branding, booking requirements, limits.</feature> <feature>Database: NeonDB (Postgres). Frontend drivers only — design must preserve security & consistency under that constraint.</feature> <feature>Auth: separate auth flows for business owners and customers. Guest bookings allowed.</feature> <feature>Notifications: email and optional SMS; transactional with retry and delivery logging.</feature> <feature>Data integrity: strict constraints, transactions, idempotency and conflict resolution patterns to prevent double-bookings. (MUST ENSURE DATA CONSISTENCY)</feature> </productScope> <tenantAndSubdomainDesign> <goal>Each tenant (business) gets a stable subdomain and isolated configuration.</goal> <requirements> <item>Wildcard DNS + TLS: support *.rivo.app pointing to the booking frontend.</item> <item>Tenant resolution: map subdomain to tenant record and to YAML config location before rendering booking UI.</item> <item>Config precedence: tenant YAML overrides platform defaults; support config versioning and validation.</item> <item>Booking page is a single, generic template that reads the tenant config and renders services, availability and booking flow.</item> </requirements> </tenantAndSubdomainDesign> <yamlConfigurationModel> <description> The YAML file is the single source of truth for per-tenant booking behavior. Validate every YAML against a schema before enabling it. </description> <requiredFields> <field>business.id — unique tenant identifier</field> <field>business.name — display name</field> <field>contact — address, email, phone</field> <field>branding — primaryColor, logoUrl, coverImageUrl</field> <field>timeSlotDuration — minutes (slot increment)</field> <field>maxSimultaneousBookings — concurrency per slot</field> <field>advanceBookingDays — how many days into future customers can book</field> <field>requireEmail, requirePhone, allowGuestBooking — booking requirements</field> <field>availability — per-day open/close times and exceptions</field> <field>categories -> services[] — service id, name, duration (minutes), price (cents), color, sortOrder</field> </requiredFields> <validation> <item>Enforce numeric bounds (e.g., timeSlotDuration > 0 and <= 480).</item> <item>Validate time formats (24h HH:MM). Validate timezone presence for tenant.</item> <item>Support an overrides mechanism for temporary changes (e.g., holiday closures).</item> </validation> </yamlConfigurationModel> <dataModelGuidelines> <goal>Define logical entities and constraints (no implementation SQL here — instruction only).</goal> <entities> <entity>business / tenant</entity> <entity>user (owners, staff, customers)</entity> <entity>service</entity> <entity>category</entity> <entity>availability / schedule / exceptions</entity> <entity>appointment</entity> <entity>reservation_token (temporary hold on a timeslot)</entity> <entity>notification_log</entity> <entity>subdomain mapping</entity> <entity>audit_log</entity> </entities> <constraintsAndIndexes> <item>Unique constraint on (business_id, service_id) where applicable.</item> <item>Unique index or constraint to prevent overlapping committed appointments beyond maxSimultaneousBookings for a timeslot.</item> <item>Index on business_id + appointment_start to speed calendar queries.</item> <item>Audit/audit_log table for changes to appointment status (created, confirmed, canceled, modified) with actor and timestamp.</item> </constraintsAndIndexes> <migrationsOverview> <item>Create migration steps that: (1) create core tables; (2) create RLS policies and roles; (3) create unique constraints and indexes; (4) seed admin account and sample tenant; (5) run schema validation tests.</item> <item>Include a migration to add a reservation/hold table with TTL semantics (expiry timestamp) to support tentative holds.</item> </migrationsOverview> <dataRetentionAndSoftDeletes> <item>Use soft deletes for appointments and business data (deleted_at). Keep audit log indefinitely.</item> </dataRetentionAndSoftDeletes> <timezones> <item>Store all timestamps in UTC in DB. Store tenant timezone and show local times on UI. Always convert and validate on client-side before writing to DB.</item> </timezones> </dataModelGuidelines> <consistencyAndConcurrency> <principles>MUST ENSURE DATA CONSISTENCY under frontend-only DB access.</principles> <mechanisms> <mechanism>Reservation flow: client creates a short-lived reservation record for a specific business/timeslot with a TTL. Reservation creation must be atomic; reservation records reserve 1 of capacity for that timeslot.</mechanism> <mechanism>Commit flow: to finalize booking, client exchanges reservation token for an appointment in a single transactional operation that verifies reservation still valid and consumes it.</mechanism> <mechanism>Unique DB constraints: enforce max simultaneous bookings at DB level (composite unique constraints or check mechanisms) so a race cannot create extra bookings.</mechanism> <mechanism>Idempotency tokens for client retries: every booking attempt uses an idempotency key stored with the reservation/appointment to allow safe retries.</mechanism> <mechanism>Optimistic locking: use a version or last_updated timestamp for edits to detect concurrent modifications and reject or reconcile conflicts.</mechanism> <mechanism>Row-Level Security (RLS): grant minimal write privileges and use JWT claims to assert tenant identity; never embed long-lived DB credentials in the client.</mechanism> <mechanism>Backstop serverless function: if frontend-only drivers cannot implement required atomic semantics safely, route critical operations through a minimal trusted function that runs transactions server-side. (Architectural note: prefer to preserve user constraint but provide a fallback option.)</mechanism> </mechanisms> <testingScenarios> <test>Simulate 100 concurrent clients attempting same timeslot to verify no overbooking.</test> <test>Simulate network retry with same idempotency key to verify single booking created.</test> <test>Verify reservation expiration and cleanup jobs remove stale reservations and free capacity.</test> </testingScenarios> </consistencyAndConcurrency> <authAndSecurity> <separationOfAuth> <item>Owner auth: scoped to tenants with roles (owner, staff). Owners must supply business info during signup.</item> <item>Customer auth: optional. Allow guest booking path that creates a lightweight customer record and issues a short-lived token tied to appointment cancellation link.</item> <item>Token management: use short-lived JWTs for direct DB access; supply scoped claims for RLS enforcement.</item> </separationOfAuth> <securityControls> <item>Never store DB credentials in plain client code. Use ephemeral token provider or Neon-managed role tokens configurable via platform.</item> <item>Enable RLS policies to prevent cross-tenant access.</item> <item>Sanitize and validate all user-supplied strings (names, emails, phone numbers).</item> <item>Use TLS everywhere. Enforce CSP and CORS rules for booking subdomains.</item> </securityControls> </authAndSecurity> <bookingFlowSpecification> <highLevelFlow> <step>Visitor opens tenant subdomain -> tenant config + availability are loaded.</step> <step>User selects category -> selects service -> UI shows available days (respecting business timezone and advanceBookingDays).</step> <step>User picks a day -> UI shows available slots computed from availability, timeSlotDuration, existing confirmed appointments, and pending reservations.</step> <step>User selects slot -> client creates reservation (short TTL) with an idempotency key -> UI prompts for contact details (email/phone) -> user submits -> client commits reservation to appointment in a transactional step -> send confirmation notification.</step> <step>If guest booking, create ephemeral customer record with a cancellation/auth token emailed to user.</step> </highLevelFlow> <edgeCases> <item>Partial overlap handling for services with durations longer than slot increment: compute occupied intervals and prevent overlaps per business rules.</item> <item>Simultaneous bookings for services that allow multiple providers or greater capacity: obey maxSimultaneousBookings.</item> <item>Timezone mismatches: validate client computed times against tenant timezone before creating reservation.</item> </edgeCases> </bookingFlowSpecification> <calendarAndDashboardGuidelines> <ownerDashboard> <capabilities> <capability>Month / week / day views and list view.</capability> <capability>Drag-and-drop reschedule with server-side validation and audit trail.</capability> <capability>Manual appointment creation (with required fields), cancellation, and bulk actions.</capability> <capability>Notifications management and quick customer contact links.</capability> </capabilities> <uxNotes> <item>Calendar must show color-coded services and capacity badges.</item> <item>Support filtering by staff member, category, and status.</item> </uxNotes> </ownerDashboard> </calendarAndDashboardGuidelines> <notificationsAndIntegrations> <channels>email (required), SMS (optional), webhooks (for third-party integrations)</channels> <reliability> <item>Record notification attempts and results in notification_log.</item> <item>Retry transient failures with exponential backoff; keep idempotency for notification sends.</item> </reliability> <integrations>calendar export (ICS), optional Google/Outlook sync, webhook for order/status changes.</integrations> </notificationsAndIntegrations> <testingAndQualityAssurance> <unitTests>Validate config parser, time slot generator, validation rules (no code here — specify tests).</unitTests> <integrationTests>Reservation + commit transactions, RLS enforcement, auth flows, reservation TTL expiration.</integrationTests> <performanceTests>Concurrent booking stress test, page load for booking template under high tenant traffic.</performanceTests> <acceptanceCriteria> <item>No overbooking in concurrency tests.</item> <item>Booking flow completes end-to-end and customers receive confirmation in 99.9% of nominal cases.</item> <item>Admin can create/modify/cancel appointments and see immediate consistent results in calendar.</item> </acceptanceCriteria> </testingAndQualityAssurance> <deploymentMonitoringBackups> <dnsAndSubdomains>Wildcard DNS + automated provisioning of TLS certificates for tenant subdomains.</dnsAndSubdomains> <observability>Application logs, DB metrics, reservation queue metrics, notification delivery metrics.</observability> <backups>Regular DB backups and point-in-time recovery; test restore procedure monthly.</backups> <failureModes> <item>If NeonDB connectivity fails, surface maintenance notice on booking pages and disable new reservations to avoid partial state.</item> </failureModes> </deploymentMonitoringBackups> <plan> <instruction>More info can be found in /docs, document new things. Execute the following steps in order. After completing each step, produce the deliverables specified for review. Do not skip steps.</instruction>


<step number="1">
  <title>Define canonical YAML schema & validation rules</title>
  <tasks>
    <task>Write formal field list, types, and validation rules for YAML (versioned schema).</task>
    <task>Define validation failure behavior and rollback rules for faulty configs.</task>
  </tasks>
  <deliverables>YAML schema spec, validation rules, sample valid/invalid scenarios (text only).</deliverables>
  <acceptance>Schema covers all business needs and edge cases described above.</acceptance>
</step>

<step number="2">
  <title>Design data model and migration plan</title>
  <tasks>
    <task>Produce a table-by-table description, constraints, indexes, and RLS policy descriptions.</task>
    <task>List migration steps in order, including seeding and rollback steps.</task>
  </tasks>
  <deliverables>Migration plan document and preflight checklist for running migrations safely.</deliverables>
  <acceptance>Plan enforces unique constraints and reservation semantics; migration order safe for live data.</acceptance>
</step>

<step number="3">
  <title>Auth and security design</title>
  <tasks>
    <task>Specify owner vs customer auth flows, token lifecycle, RLS claim mapping, guest booking token design.</task>
    <task>Define minimal privilege required for frontend DB operations and ephemeral token provisioning mechanism.</task>
  </tasks>
  <deliverables>Auth spec, token issuance flow, RLS claim matrix.</deliverables>
  <acceptance>Separation of roles documented and secure token lifecycle defined.</acceptance>
</step>

<step number="4">
  <title>Booking transaction & concurrency design</title>
  <tasks>
    <task>Specify reservation -> commit -> confirm lifecycle with TTL, idempotency, and failure handling.</task>
    <task>Define how DB constraints will serve as backstop and how conflicts are surfaced to the client.</task>
  </tasks>
  <deliverables>Transactional flow  and error cases with remediation steps.</deliverables>
  <acceptance>Concurrency scenarios covered; test plan defined to prove no overbooking.</acceptance>
</step>

<step number="5">
  <title>DONT DO THIS</title>
  <tasks>
    <task>Describe tenant resolution, caching strategy, YAML sourcing and validation on load, and fallback behavior.</task>
    <task>Define DNS, cert, and CDN requirements for wildcard subdomains.</task>
  </tasks>
  <deliverables>Tenant routing & config resolution doc and CDN/DNS checklist.</deliverables>
  <acceptance>Booking pages load securely with correct tenant configs applied.</acceptance>
</step>

<step number="6">
  <title>Owner dashboard UX & interactions</title>
  <tasks>
    <task>Detail calendar interactions, manual appointment creation UX, drag/drop reschedule rules, and audit behaviors.</task>
    <task>Define acceptance criteria for each interaction and API contract expectations.</task>
  </tasks>
  <deliverables>Owner dashboard and mock data scenarios for QA.</deliverables>
  <acceptance>All UX actions map to atomic server operations that preserve consistency.</acceptance>
</step>

<step number="7">
  <title>Public booking UX & slot generation</title>
  <tasks>
    <task>Describe slot generation algorithm, display rules, pagination/scrolling for long date ranges.</task>
    <task>Define guest booking experience and minimal data required, and cancellation link flow.</task>
    <task>Create YAML-based tenant configuration system for per-business customization.</task>
    <task>Build customer-facing booking pages with dynamic config loading and subdomain routing.</task>
  </tasks>
  <deliverables>Booking flow spec, YAML schema, config validation system, booking page implementation, UX edge cases, and telemetry hooks to track drop-off points.</deliverables>
  <acceptance>Booking flow covers all configuration permutations (e.g., required email/phone, capacity limits). YAML configs validate correctly and populate booking pages dynamically.</acceptance>
</step>

<step number="7a">
  <title>Multi-business ownership database migration</title>
  <tasks>
    <task>Create business_owners junction table for many-to-many business-owner relationships.</task>
    <task>Migrate existing business_id data from users table to junction table without data loss.(now its mock data so we can afford to loose data if needed)</task>
    <task>Add is_primary flag to identify default/primary business for each owner.</task>
    <task>Keep users.business_id column for backward compatibility and as primary business reference.</task>
    <task>Create sync triggers to maintain consistency between users.business_id and business_owners table.</task>
    <task>Add helper functions: get_user_businesses(user_id), user_owns_business(user_id, business_id).</task>
    <task>Create indexes for fast business-owner lookups.</task>
  </tasks>
  <deliverables>Migration SQL file, junction table schema, sync triggers, helper functions, rollback plan, migration verification queries.update docs. update onboarding.</deliverables>
  <acceptance>Existing business_id relationships preserved in junction table. Owners can be associated with multiple businesses. Primary business properly tracked. No data loss during migration. Backward compatibility maintained.</acceptance>
</step>

<step number="7b">
  <title>Business onboarding pipeline - Admin/YAML flow</title>
  <tasks>
    <task>Create automated onboarding system that accepts YAML config and owner email.</task>
    <task>Generate secure temporary credentials (OTP-style password) for first-time owner access.</task>
    <task>Implement email verification flow with secure tokens.</task>
    <task>Build first-login onboarding wizard requiring immediate password change.</task>
    <task>Ensure complete data consistency: YAML config → business DB record → owner account → services → booking page.</task>
    <task>Handle edge cases: existing owner (associate new business using junction table), duplicate subdomain, invalid YAML, DB conflicts.</task>
    <task>Use business_owners junction table to support multi-business per owner with proper primary business tracking.</task>
  </tasks>
  <deliverables>Onboarding CLI tool, admin API endpoint, admin onboarding web interface, credential generation system, welcome email templates, error handling documentation.</deliverables>
  <acceptance>Complete business setup from YAML creates all DB records, owner can verify email and login, must change password on first access, bookings from customers appear in owner dashboard. Existing owners can add new businesses via junction table. Clear error messages for all failure modes.</acceptance>
</step>

<step number="7c">
  <title>Self-service onboarding - Public signup flow</title>
  <tasks>
    <task>Build form-based public signup wizard that collects all YAML properties through UI.</task>
    <task>Multi-step form: business info → contact details → branding → services/categories → availability → booking rules → review.</task>
    <task>Generate YAML configuration from form data for validation and storage.</task>
    <task>Real-time validation of each step (subdomain availability, service duration compatibility, etc).</task>
    <task>Allow owner to create account during signup (email/password) or link to existing owner account.</task>
  </tasks>
  <deliverables>Public signup form wizard, YAML generator from form data, validation system, preview functionality, subdomain availability checker.</deliverables>
  <acceptance>Non-technical business owners can self-onboard without YAML knowledge. Form validates in real-time. Generated config matches YAML schema.Process completes with functional business and booking page.</acceptance>
</step>

<step number="7d">
  <title>Password management & account recovery</title>
  <tasks>
    <task>Implement "forgot password" flow with secure reset tokens and email delivery.</task>
    <task>Build password change functionality with old password verification.</task>
    <task>Create forced password change on first login for onboarded owners.</task>
    <task>Add password strength requirements and validation.</task>
    <task>Implement rate limiting for password reset requests.</task>
  </tasks>
  <deliverables>Password reset flow, password change UI, first-login password enforcement, security policies documentation.</deliverables>
  <acceptance>Owners can reset forgotten passwords securely. First-time login requires password change. Password policies enforced. Rate limiting prevents abuse.</acceptance>
</step>

<step number="7e">
  <title>Service external ID mapping for YAML-to-DB consistency</title>
  <tasks>
    <task>Add external_id column to services table to store YAML config IDs (slugs like "swedish-massage-60").</task>
    <task>Create unique constraint on (business_id, external_id) to ensure slug uniqueness per business.</task>
    <task>Update business onboarding pipeline to populate external_id from YAML service.id during service creation.</task>
    <task>Modify all booking API endpoints to accept and resolve service lookups by external_id OR UUID.</task>
    <task>Update /api/booking/reserve to handle external_id parameter and resolve to database UUID internally.</task>
    <task>Update /api/booking/slots response to include both id (UUID) and external_id for client flexibility.</task>
    <task>Create database helper function get_service_uuid(business_id, external_id) for consistent lookups.</task>
    <task>Add data migration to backfill external_id for existing services using name-based slugification as fallback.</task>
    <task>Update YAML validation to enforce external_id format rules (lowercase, alphanumeric with hyphens).</task>
    <task>Document the dual-ID system: external_id for YAML/API contracts, UUID for internal foreign keys.</task>
  </tasks>
  <deliverables>Migration SQL adding external_id column and constraints, updated onboarding code, modified booking API endpoints, service lookup helper function, backfill migration for existing data, updated API documentation showing both ID types, validation rules for external_id format.</deliverables>
  <acceptance>YAML service IDs map reliably to database records. Booking flow works with external_ids from config. No UUID exposure to public booking API. Existing services backfilled with valid external_ids. All service lookups use consistent resolution logic. API accepts both UUID (for internal/dashboard) and external_id (for public booking).</acceptance>
</step>

<step number="7f">
  <title>Flexible service duration and time slot handling (5-minute grain block system)</title>
  <tasks>
    <task>Implement 5-minute grain block system as universal time grid for all scheduling operations.</task>
    <task>Update YAML validation to auto-round durations, buffers, and timeSlotDuration to nearest 5min multiple (with console info logs).</task>
    <task>Refactor slot-generator to use 5min grain blocks: timeSlotDuration becomes DISPLAY interval, services can be any 5min multiple.</task>
    <task>Implement intelligent slot allocation that handles services spanning multiple time slots (e.g., 45min service in 30min display slots).</task>
    <task>Add overlap detection using grain block precision: check if intervals [start1, end1) and [start2, end2) conflict.</task>
    <task>Update availability API to correctly show available slots for services of varying durations (15, 45, 75, 90, 105 min).</task>
    <task>Handle edge cases: service ending mid-slot, overlapping bookings prevention, buffer time calculations at 5min granularity.</task>
    <task>Export snapToGrain() utility function for use across codebase (calendar drag-and-drop, manual entry, etc).</task>
  </tasks>
  <deliverables>5-minute grain block system implementation, updated tenant-schema.ts with auto-rounding transforms, refactored slot-generator.ts, snapToGrain() utility in calendar-utils.ts, test YAML config with edge case durations (15, 45, 75, 105 min).</deliverables>
  <acceptance>Services with any 5min-multiple duration work correctly with any timeSlotDuration. Slot availability accurately reflects occupied time using grain block overlap detection. No double-bookings occur. YAML auto-rounds non-multiples of 5 with info logs. Drag-and-drop snaps to 5min grid.</acceptance>
</step>

<step number="7g">
  <title>Appointment drag-and-drop rescheduling with validation</title>
  <tasks>
    <task>Implement drag-and-drop rescheduling in month, week, and day calendar views with 5-minute grain snap.</task>
    <task>Create API endpoint POST /api/appointments/reschedule that validates new time slot availability before committing.</task>
    <task>Run same validation checks as booking flow: slot availability, capacity limits, business hours, advance booking limits, overlaps.</task>
    <task>Check slot capacity using existing slot-generator logic: verify new time has available capacity considering service duration + buffers.</task>
    <task>Implement optimistic locking: check appointment.updated_at hasn't changed since drag started to prevent concurrent modification conflicts.</task>
    <task>Show confirmation alert after successful reschedule: "Appointment rescheduled. Customer will be notified via email."</task>
    <task>Send notification email to customer with updated appointment time, cancellation link, and calendar attachment (.ics).</task>
    <task>Add audit log entry recording who rescheduled, old time, new time, and timestamp.</task>
    <task>Handle drag validation failures gracefully: show error toast with specific reason (fully booked, outside business hours, etc).</task>
    <task>Implement visual feedback during drag: highlight valid drop zones in green, invalid in red, show capacity indicator.</task>
  </tasks>
  <deliverables>Drag-and-drop UI implementation in Calendar.tsx (month/week/day views), POST /api/appointments/reschedule endpoint, slot availability validation logic, customer notification email template, audit logging, error handling with user-friendly messages.</deliverables>
  <acceptance>Owner can drag appointments to new time slots. System validates availability using same logic as booking flow. Invalid drops are rejected with clear error messages. Customer receives email notification on successful reschedule. Audit log captures all reschedule operations. No double-bookings or capacity violations occur.</acceptance>
</step>

<step number="7h">
  <title>Appointment edit modal for detailed modifications</title>
  <tasks>
    <task>Add edit button (pencil icon) on appointment hover in all calendar views (month, week, day, list).</task>
    <task>Create AppointmentEditModal component with form fields: date, start time (5min grain dropdown), service selector, customer info, notes, status.</task>
    <task>In list view, clicking appointment or edit button opens modal instead of inline edit.</task>
    <task>Implement time picker with 5-minute grain increments (9:00, 9:05, 9:10, etc) respecting business hours from YAML config.</task>
    <task>Add service selector dropdown that updates duration and end time preview automatically.</task>
    <task>Show real-time availability check: display capacity indicator and conflicts warning as user changes date/time.</task>
    <task>Validate form before submission: check slot availability, business hours, capacity, customer required fields.</task>
    <task>Support status changes (confirmed, cancelled, completed, no_show) with confirmation prompts for cancellations.</task>
    <task>Add "Notify customer" checkbox (default checked) to control whether customer receives update email.</task>
    <task>Implement optimistic UI updates: update calendar immediately on save, revert on error with toast notification.</task>
    <task>Add delete/cancel appointment action with confirmation dialog: "Cancel this appointment? Customer will be notified."</task>
  </tasks>
  <deliverables>AppointmentEditModal.tsx component, edit button overlay on hover, 5min-grain time picker, service selector with duration preview, real-time availability validation, status change controls, customer notification toggle, delete/cancel action, optimistic UI updates.</deliverables>
  <acceptance>Edit button appears on appointment hover in all views. Modal opens with pre-filled appointment data. Time picker shows 5-minute increments within business hours. Service changes update duration and availability in real-time. Slot validation prevents overbooking. Customer receives email when "Notify customer" is checked. Status changes and cancellations work correctly. UI updates optimistically with error rollback.</acceptance>
</step>

<step number="8">
  <title>Notifications & external integrations</title>
  <tasks>
    <task>Specify notification templates, retry logic, and webhook contract for third-party integrations.</task>
    <task>Implement welcome emails with temporary credentials for onboarded owners.</task>
    <task>Create email verification and password reset notification templates.</task>
  </tasks>
  <deliverables>Notification spec and integration checklist (email provider, SMS provider, webhook schemas). Welcome email system. Transactional email templates.</deliverables>
  <acceptance>Notifications are idempotent and logged for auditing. Onboarding emails deliver credentials securely. Email verification works reliably.</acceptance>
</step>

<step number="9">
  <title>Testing, stress and QA runbook</title>
  <tasks>
    <task>Detail unit/integration/performance tests and concurrency test harness design.</task>
    <task>Define metrics to monitor before promoting to production.</task>
  </tasks>
  <deliverables>QA runbook and test case matrix.</deliverables>
  <acceptance>Pass concurrency and regression tests; acceptable error rates under load.</acceptance>
</step>

<step number="10">
  <title>Deployment, monitoring, and backup plan</title>
  <tasks>
    <task>Document CI/CD steps, migration procedure for production, rollout strategy and rollback steps.</task>
    <task>Define monitoring dashboards and alert thresholds.</task>
  </tasks>
  <deliverables>Deployment playbook and monitoring dashboard spec.</deliverables>
  <acceptance>Automated deploys, tested rollback, and monitored health checks in place.</acceptance>
</step>

<step number="11">
  <title>Business Discovery Interface</title>
  <tasks>
    <task>Build public discovery page at /book (no subdomain) that aggregates all active businesses on the platform.</task>
    <task>Implement interactive map view showing business locations with markers and clustering for dense areas.</task>
    <task>Create list view with business cards showing name, services, next available slot, distance, and rating.</task>
    <task>Design comprehensive filter system: category (salon, spa, clinic, etc.), service type, price range, opening hours, distance radius, availability (today, this week, date range).</task>
    <task>Add search functionality with autocomplete for business name, service keywords, and location/address.</task>
    <task>Implement geolocation to show nearby businesses and calculate distances.</task>
    <task>Build business detail preview modal or card with summary, photos, top services, hours, and reviews.</task>
    <task>Create seamless redirect flow: clicking a business navigates to /book/[subdomain] for the full booking experience.</task>
    <task>Add sort options: nearest, soonest availability, highest rated, price low-to-high.</task>
    <task>Design empty states for no results and encourage filter adjustment.</task>
    <task>Optimize for performance with pagination or infinite scroll and lazy-loaded map tiles.</task>
  </tasks>
  <deliverables>Discovery page UI/UX spec, filter and search system design, map integration plan (Mapbox/Google Maps), routing logic, empty state designs, performance optimization strategy.</deliverables>
  <acceptance>Customers can browse all businesses, filter by multiple criteria, see locations on map, and seamlessly navigate to booking flow. Page loads quickly even with hundreds of businesses. Filters work in real-time and are reflected in both map and list views.</acceptance>
</step>

<step number="12">
  <title>Business Discovery Data Layer</title>
  <tasks>
    <task>Extend database schema to support discovery: add latitude/longitude, address components, business description, cover photo, featured services, operating hours summary to business table.</task>
    <task>Create indexed queries for geospatial search (ST_Distance or equivalent) and multi-criteria filtering.</task>
    <task>Build API endpoint /api/businesses/discover that accepts filter parameters and returns paginated results with metadata.</task>
    <task>Implement caching layer for discovery results (Redis or in-memory) with TTL to reduce DB load.</task>
    <task>Add business visibility toggle (active/hidden from discovery) to owner settings.</task>
    <task>Create batch job to refresh "next available slot" metadata for each business hourly.</task>
    <task>Build review/rating system (future) infrastructure if not present, or stub for later integration.</task>
    <task>Ensure RLS policies allow public read access to discovery-relevant business fields while protecting private data.</task>
  </tasks>
  <deliverables>Database migration for discovery fields, geospatial indexes, discovery API spec and implementation, caching strategy, admin toggle for visibility.</deliverables>
  <acceptance>Discovery API returns accurate, filtered business lists in &lt;500ms. Geolocation queries work correctly. Business owners can control discovery visibility. Next available slot data is fresh and accurate.</acceptance>
</step>

<step number="11a">
  <title>Geocoding Integration for Business Onboarding</title>
  <tasks>
    <task>Extend YAML schema to include geolocation fields: latitude (DECIMAL 10,8) and longitude (DECIMAL 11,8).</task>
    <task>Update tenant-schema.ts Zod validators to accept and validate latitude/longitude fields.</task>
    <task>Add address geocoding to onboarding flow: accept full address input and convert to lat/long coordinates.</task>
    <task>Implement geocoding service using free Nominatim API (OpenStreetMap) or similar geocoding service.</task>
    <task>Create address autocomplete/validation component that suggests addresses and shows coordinates preview.</task>
    <task>Store geocoded coordinates in YAML config alongside address for discovery map display.</task>
    <task>Add fallback geocoding: if coordinates not in YAML, geocode from address on-the-fly and cache result.</task>
    <task>Update existing YAML configs (wellness-spa, bella-salon) with geocoded coordinates for Italian addresses.</task>
    <task>Modify discovery API to prioritize YAML coordinates over hardcoded city lookups.</task>
  </tasks>
  <deliverables>Updated YAML schema with lat/long fields, geocoding service implementation, address input component with preview, backfilled YAML configs with coordinates, updated discovery API.</deliverables>
  <acceptance>Onboarding flow captures address and automatically geocodes to lat/long. Coordinates stored in YAML. Discovery map displays businesses at accurate locations. No hardcoded city coordinates needed.</acceptance>
</step>

<step number="11b">
  <title>Map Business Overview Cards - Hover and Zoom Interactions</title>
  <tasks>
    <task>Implement hover interaction on map markers: show compact business card overlay when mouse hovers over marker.</task>
    <task>Design minimal business overview card with: business name, primary service category, next available slot, distance from user, and thumbnail image.</task>
    <task>Add zoom-based clustering: when zoomed out, group nearby businesses into cluster markers showing count.</task>
    <task>On cluster click or hover, display aggregated overview: "X businesses in this area" with preview of top 3 businesses.</task>
    <task>Implement smooth transitions: fade in/out animations for cards, scale markers on hover, highlight active business.</task>
    <task>Create side panel (optional): when marker is clicked, slide in detailed panel from side with full business info and quick book CTA.</task>
    <task>Add keyboard navigation: allow tab through markers, space/enter to open card, escape to close.</task>
    <task>Optimize performance: debounce hover events, lazy load business images, virtual rendering for large cluster counts.</task>
    <task>Mobile UX: convert hover to tap interaction, show bottom sheet instead of overlay on mobile screens.</task>
  </tasks>
  <deliverables>Hover card component, cluster marker logic, zoom-level business aggregation, side panel UI (optional), keyboard navigation implementation, mobile-responsive interaction patterns.</deliverables>
  <acceptance>Hovering over marker shows business summary instantly. Clusters display on zoom out with business count. Click/tap opens detailed view. Smooth 60fps animations. Works seamlessly on desktop and mobile. Keyboard accessible.</acceptance>
</step>

<step number="13">
  <title>Post-launch: telemetry, iterative improvements</title>
  <tasks>
    <task>Collect usage data to validate UX assumptions; plan A/B experiments for conversion uplift.</task>
    <task>Track discovery page metrics: search queries, filter usage, map vs list view preference, click-through rate to booking pages.</task>
  </tasks>
  <deliverables>Metric definitions and first 90-day measurement plan. Discovery funnel analytics.</deliverables>
  <acceptance>Telemetry captures booking funnel, reservation TTL expirations, failure modes, and discovery-to-booking conversion rates.</acceptance>
</step>
</plan> <nonFunctionalRequirements> <nfr>Accessibility: WCAG AA baseline for booking flows and owner dashboard.</nfr> <nfr>Performance: booking page first meaningful paint under 1.5s on 3G simulated (optimize assets, critical CSS).</nfr> <nfr>Security: RLS, TLS, CSP, audit logs for appointment changes.</nfr> <nfr>Scalability: design for many tenants and burst booking events; caching of tenant configs.</nfr> </nonFunctionalRequirements> <deliverableFormat> <format>For each step, return: objectives, tasks, acceptance criteria, risks and mitigations, and a short checklist of artefacts to produce next.</format> . Preserve the constraints: NO EMOJIS, NO AI BUZZWORDS, and MUST ENSURE DATA CONSISTENCY.</text> </closingInstruction> </claudePrompt>